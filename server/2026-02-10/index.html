<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KiX server Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<style>
*,*::before,*::after{box-sizing:border-box;}
:root {
  --bg: #f8f9fa;
  --card-bg: #ffffff;
  --border: #e5e7eb;
  --border-light: #f3f4f6;
  --text: #1f2937;
  --text-secondary: #6b7280;
  --text-muted: #9ca3af;
  --accent: #3b82f6;
  --accent-light: #dbeafe;
  --accent-dark: #2563eb;
  --success: #10b981;
  --success-light: #d1fae5;
  --warning: #f59e0b;
  --danger: #ef4444;
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  --maxw: 96%;
  --pagePadX: 20px;
  --r: 12px;
  --r2: 8px;
}

* { 
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
  font-size: 14px;
  line-height: 1.6;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.container {
  max-width: var(--maxw);
  margin: 0 auto;
  padding: 20px;
}

/* Header */
.header {
  background: var(--card-bg);
  padding: 24px 32px;
  margin: -20px -20px 24px;
  border-bottom: 1px solid var(--border);
  box-shadow: var(--shadow-sm);
}

.header h1 {
  font-size: 32px;
  font-weight: 700;
  margin: 0 0 8px;
  color: var(--text);
  background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.header-info {
  display: flex;
  gap: 24px;
  font-size: 14px;
  color: var(--text-secondary);
}

.header-info span {
  display: flex;
  align-items: center;
  gap: 6px;
}

.header-info strong {
  color: var(--text);
  font-weight: 600;
}

/* å¯¼èˆªæ  */
.nav-tabs {
  position: sticky;
  top: 0;
  z-index: 100;
  background: var(--card-bg);
  padding: 16px 0;
  margin: 0 -20px 32px;
  border-bottom: 2px solid var(--border-light);
  box-shadow: var(--shadow-sm);
  display: flex;
  gap: 8px;
  overflow-x: auto;
  padding-left: 20px;
  padding-right: 20px;
  align-items: center;
}

/* æœç´¢æ¡†å®¹å™¨ */
.search-container {
  position: relative;
  margin-left: auto; 
  flex-shrink: 0;
}

.metric-search-input {
  width: 280px;
  padding: 10px 16px;
  border: 1px solid var(--border);
  border-radius: var(--r);
  background: var(--bg);
  color: var(--text);
  font-size: 14px;
  font-family: inherit;
  transition: all 0.2s;
  outline: none;
}

.metric-search-input:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.metric-search-input::placeholder {
  color: var(--text-muted);
}

/* æœç´¢ç»“æœä¸‹æ‹‰æ¡† */
.search-results {
  position: fixed;
  top: 120px;  /* å›ºå®šåœ¨é¡µé¢é¡¶éƒ¨ä¸‹æ–¹ */
  right: 20px; /* å³ä¾§å¯¹é½ */
  width: 400px; /* å›ºå®šå®½åº¦ */
  max-height: calc(100vh - 140px); /* æœ€å¤§é«˜åº¦ä¸ºè§†å£é«˜åº¦å‡å»é¡¶éƒ¨é—´è· */
  overflow-y: auto;
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--r);
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); /* æ›´å¼ºçš„é˜´å½± */
  display: none;
  z-index: 9999; /* æ›´é«˜çš„å±‚çº§ */
}

.search-results.show {
  display: block;
}

.search-result-item {
  padding: 12px 16px;
  cursor: pointer;
  border-bottom: 1px solid var(--border-light);
  transition: background 0.15s;
}

.search-result-item:last-child {
  border-bottom: none;
}

.search-result-item:hover {
  background: var(--accent-light);
}

.search-result-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 4px;
}

.search-result-domain {
  font-size: 11px;
  color: var(--text-muted);
}

.search-no-results {
  padding: 16px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
}

/* é«˜äº®åŠ¨ç”» */
@keyframes highlight-pulse {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
    border-color: var(--border);
  }
  50% {
    box-shadow: 0 0 0 8px rgba(59, 130, 246, 0);
    border-color: var(--accent);
  }
}

.chart-card.highlight {
  animation: highlight-pulse 1.5s ease-in-out 2;
  border-color: var(--accent);
}

.nav-tabs::-webkit-scrollbar {
  height: 6px;
}

.nav-tabs::-webkit-scrollbar-track {
  background: var(--border-light);
  border-radius: 3px;
}

.nav-tabs::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 3px;
}

.nav-tabs::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

.nav-tab {
  flex-shrink: 0;
  padding: 10px 20px;
  border-radius: var(--r);
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  white-space: nowrap;
  letter-spacing: -0.01em;
}

.nav-tab:hover {
  background: var(--card-bg);
  border-color: var(--accent);
  color: var(--text);
  transform: translateY(-1px);
  box-shadow: var(--shadow);
}

.nav-tab.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
  box-shadow: var(--shadow);
}

/* AI åˆ†æé¢æ¿ï¼ˆæ–¹æ¡ˆAï¼šå¯¼èˆªä¸‹æ–¹å›ºå®šå ä½ï¼Œä¸é®æŒ¡å›¾è¡¨ï¼‰ */
:root { --aiw: {aiw_px}px; --ai-top: 86px; }

/* ä¸¤åˆ—å¸ƒå±€ï¼šå·¦ä¾§å›¾è¡¨ï¼Œå³ä¾§ AI é¢æ¿ï¼ˆä¸ overlayï¼‰ */
.content-layout{
  display: flex;
  gap: 14px;
  align-items: flex-start;
}

.main-area{
  flex: 1 1 auto;
  min-width: 0; /* å…è®¸å†…éƒ¨å›¾è¡¨è‡ªé€‚åº”ç¼©æ”¾ */
}

/* AI é¢æ¿ï¼šä»å¯¼èˆªæ ä¸‹æ–¹å¼€å§‹ sticky */
.ai-panel{
  width: var(--aiw);
  min-width: var(--aiw);
  max-width: var(--aiw);
  flex: 0 0 var(--aiw);
  position: sticky;
  top: var(--ai-top);
  height: calc(100vh - var(--ai-top) - 16px);
  background: var(--card-bg);
  border: 1px solid var(--border-light);
  border-radius: 16px;
  box-shadow: var(--shadow-md);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* æŠ˜å ï¼šAI é¢æ¿å®½åº¦å˜ 0ï¼Œä¸»å†…å®¹å æ»¡ */
body.ai-collapsed .ai-panel{
  width: 0 !important;
  min-width: 0 !important;
  max-width: 0 !important;
  flex: 0 0 0 !important;
  border: none;
  box-shadow: none;
  padding: 0;
  margin: 0;
}

/* æŠ˜å æ—¶æ˜¾ç¤ºä¸€ä¸ªå°æŠŠæ‰‹ï¼ˆä¸æŒ¡å›¾è¡¨ï¼‰ */
.ai-expand-handle{
  position: sticky;
  top: calc(var(--ai-top) + 10px);
  margin-left: -6px;
  align-self: flex-start;
  width: 38px;
  height: 38px;
  border-radius: 12px;
  border: 1px solid var(--border-light);
  background: var(--card-bg);
  box-shadow: var(--shadow-sm);
  color: var(--text);
  font-weight: 700;
  cursor: pointer;
  display: none;
}
body.ai-collapsed .ai-expand-handle{ display: inline-flex; align-items:center; justify-content:center; }

.ai-panel-header{
  padding: 14px 14px 10px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--border-light);
  background: linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0));
}
.ai-panel-title{
  display:flex;
  align-items:center;
  gap:10px;
  font-size: 14px;
  font-weight: 700;
  color: var(--text);
}
.ai-dot{
  width: 10px;
  height: 10px;
  border-radius: 999px;
  background: linear-gradient(135deg, var(--primary), #4dabf7);
  box-shadow: 0 0 0 4px rgba(34,139,230,0.12);
}
.ai-panel-actions{ display:flex; gap:8px; }
.ai-panel-btn{
  width: 34px;
  height: 34px;
  border-radius: 12px;
  border: 1px solid var(--border-light);
  background: var(--card-bg);
  color: var(--text-muted);
  cursor: pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  transition: all .15s ease;
}
.ai-panel-btn:hover{
  color: var(--text);
  border-color: rgba(0,0,0,0.12);
  box-shadow: var(--shadow-sm);
}

.ai-panel-subtitle{
  padding: 10px 14px 12px;
  font-size: 12px;
  color: var(--text-muted);
  line-height: 1.5;
}

.ai-panel-content{
  padding: 12px 14px 16px;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
}

.ai-panel-content .ai-empty{
  border: 1px dashed var(--border-light);
  border-radius: 14px;
  padding: 14px;
  color: var(--text-muted);
  background: rgba(0,0,0,0.02);
}

.ai-panel-content .ai-block{
  border: 1px solid var(--border-light);
  border-radius: 14px;
  padding: 12px 12px 10px;
  background: #fff;
  box-shadow: var(--shadow-sm);
  margin-bottom: 12px;
}

.ai-panel-content .ai-kv{
  display:flex;
  flex-wrap:wrap;
  gap:8px 10px;
  margin: 8px 0 10px;
}
.ai-panel-content .ai-pill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid var(--border-light);
  background: rgba(34,139,230,0.06);
  color: var(--text);
  font-size: 12px;
}
.ai-panel-content ul{ padding-left: 18px; margin: 8px 0 0; }
.ai-panel-content li{ margin: 6px 0; color: var(--text); line-height: 1.55; }
.ai-panel-content li.ai-section{
  margin-top: 10px;
  font-weight: 700;
  color: #0f172a;
  list-style: none;
}

/* Sidebar header / close button */


/* AI content typography */
.ai-metric-title{
  font-size: 18px;
  font-weight: 800;
  color: #0f172a;
  margin: 0 0 14px 0;
  padding-bottom: 10px;
  border-bottom: 1px solid #eef2f7;
}
.ai-point{
  margin: 12px 0;
  padding: 12px 12px 12px 12px;
  background: #fbfdff;
  border: 1px solid #eef2f7;
  border-left: 4px solid #3b82f6;
  border-radius: 12px;
}
.ai-point-title{
  color:#1d4ed8;
  font-weight: 700;
  margin-bottom: 6px;
}
.ai-point-content{
  color:#334155;
  line-height: 1.65;
  font-size: 13.5px;
}


/* å°å±é™çº§ï¼šæ”¹å›è¦†ç›–å¼ï¼ˆä¸ç„¶å†…å®¹å¤ªçª„ï¼‰ */
@media (max-width: 980px){
    }
.ai-metric-title {
  font-size: 20px;
  font-weight: 600;
  color: #1f2937;
  margin-bottom: 20px;
  padding-bottom: 12px;
  border-bottom: 2px solid #e5e7eb;
}

.ai-point {
  margin-bottom: 16px;
  padding: 12px;
  background: #f9fafb;
  border-radius: 8px;
  border-left: 3px solid #3b82f6;
}

.ai-point-title {
  color: #3b82f6;
  font-weight: 600;
  margin-bottom: 4px;
}

.ai-point-content {
  color: #4b5563;
  line-height: 1.6;
}

@media (max-width: 768px) {
  }

/* AIåˆ†æå†…å®¹æ ·å¼ - æç®€ç‰ˆ */
.ai-analysis-text h3 {
  font-size: 15px;
  font-weight: 600;
  color: #111827;
  margin: 18px 0 10px 0;
  padding-bottom: 4px;
  border-bottom: 1px solid #e5e7eb;
}

.ai-analysis-text h3:first-child {
  margin-top: 0;
}

.ai-analysis-text .tldr-section {
  margin-bottom: 12px;
  color: #6b7280;
  line-height: 1.6;
}

.ai-analysis-text .domain-item {
  margin: 6px 0 6px 0;
  color: #4b5563;
  line-height: 1.6;
}

.ai-analysis-text .domain-name {
  font-weight: 600;
  color: #111827;
}

.ai-analysis-text .domain-name::after {
  content: ": ";
}

.ai-analysis-text .chain-item {
  margin: 6px 0 6px 0;
  color: #4b5563;
  line-height: 1.6;
}

.ai-analysis-text .confidence-section {
  margin-top: 12px;
  color: #6b7280;
  line-height: 1.6;
}

.ai-analysis-text strong {
  font-weight: 600;
  color: #111827;
}

/* é¢åŒ…å±‘å¯¼èˆª */
.metric-detail-breadcrumb {
  margin: 24px 0 16px;
  padding: 16px 20px;
  background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
  border: 1px solid #fbbf24;
  border-radius: var(--r);
  box-shadow: var(--shadow-sm);
}

.breadcrumb-content {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 20px;
}

.back-button {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background: white;
  border: 1px solid #f59e0b;
  border-radius: 8px;
  color: #d97706;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.back-button:hover {
  background: #fffbeb;
  border-color: #d97706;
  transform: translateX(-2px);
}

.back-button svg {
  width: 18px;
  height: 18px;
}

.breadcrumb-path {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  color: #92400e;
}

.breadcrumb-item {
  font-weight: 500;
}

.breadcrumb-item.current {
  font-weight: 700;
  color: #78350f;
}

.breadcrumb-separator {
  color: #d97706;
  font-weight: 600;
}

/* è¯¦æƒ…é¡µæ¨¡å¼ */
.detail-mode .chart-card {
  cursor: default;
}

.chart-card.current-metric {
  border: 2px solid #3b82f6;
  background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
}

.chart-card.related-metric {
  opacity: 1;
}

.module-row.hidden-module {
  display: none;
}

.module-header.related-section {
  background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
  border-bottom: 2px solid #86efac;
}

.module-header.related-section h2::before {
  content: "ğŸ”— ";
}

/* æ¨¡å— */
.modules {
  display: flex;
  flex-direction: column;
  gap: 32px;
}

.module-row {
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--r);
  overflow: hidden;
  scroll-margin-top: 100px;
  box-shadow: var(--shadow-sm);
  transition: box-shadow 0.2s ease;
}

.module-row:hover {
  box-shadow: var(--shadow);
}

.module-header {
  background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
  padding: 20px 24px;
  border-bottom: 1px solid var(--border-light);
}

.module-header h2 {
  margin: 0 0 4px;
  font-size: 20px;
  font-weight: 700;
  color: var(--text);
  letter-spacing: -0.02em;
}

.module-header p {
  margin: 0;
  font-size: 13px;
  color: var(--text-secondary);
}

.module-body {
  padding: 24px;
}

.charts {
  display: grid;
  /* AI é¢æ¿å±•å¼€æ—¶ï¼šæ›´å€¾å‘ 2 åˆ—ï¼ˆæ¯å¡æ›´å®½æ›´æ˜“è¯»ï¼‰ */
  grid-template-columns: repeat(auto-fit, minmax(520px, 1fr));
  gap: 24px;
}

/* AI é¢æ¿æŠ˜å åï¼šå…è®¸æ›´å¤šåˆ—ï¼Œå……åˆ†åˆ©ç”¨å…¨å®½ */
body.ai-collapsed .charts{
  grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
}

@media (max-width: 1100px){
  .content-layout{ display:block; }
  .ai-panel{ position: relative; top: 0; height: auto; width: 100%; flex: none; margin-top: 14px; }
  body.ai-collapsed .ai-panel{ display:none; }
  body.ai-collapsed .ai-expand-handle{ display:none; }
  .charts{ grid-template-columns: 1fr !important; }
}

/* Sidebar æ‰“å¼€æ—¶ï¼Œå›¾è¡¨ç½‘æ ¼ä» 3 åˆ—æ”¶æ•›åˆ° 2 åˆ—ï¼ˆé¿å…è¿‡çª„ï¼‰ */
@media (max-width: 1200px){
  }


@media (max-width: 768px) {
  .charts {
    grid-template-columns: 1fr;
  }
}

/* å›¾è¡¨å¡ç‰‡ */
.chart-card {
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--r2);
  padding: 20px;
  min-height: 380px;
  transition: all 0.2s ease;
  box-shadow: var(--shadow-sm);
}

.chart-card:hover {
  box-shadow: var(--shadow);
  border-color: var(--accent-light);
  transform: translateY(-2px);
}

.chart-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border-light);
}

.chart-header-right {
  display: flex;
  align-items: center;
  gap: 12px;
}

.chart-title {
  font-size: 16px;
  font-weight: 600;
  color: var(--text);
  letter-spacing: -0.01em;
}

.ai-badge{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  margin-left:10px;
  padding:2px 8px;
  font-size:12px;
  font-weight:700;
  color:#2563eb;
  background:rgba(37,99,235,0.10);
  border:1px solid rgba(37,99,235,0.25);
  border-radius:999px;
  cursor:pointer;
  user-select:none;
}
.ai-badge:hover{
  background:rgba(37,99,235,0.16);
  border-color:rgba(37,99,235,0.35);
}


/* View Details é“¾æ¥ */
.view-details-link-wrapper {
  display: flex;
  justify-content: flex-end;
  padding: 0 20px 16px 20px;
  margin-top: -8px;
}

.view-details-link {
  color: #3b82f6;
  font-size: 13px;
  font-weight: 500;
  text-decoration: none;
  cursor: pointer;
  transition: all 0.2s ease;
  letter-spacing: 0.01em;
}

.view-details-link:hover {
  color: #2563eb;
  transform: translateX(2px);
}

/* è¯¦æƒ…æ¨¡å¼ä¸‹éšè—View Detailsé“¾æ¥ */
.detail-mode .view-details-link-wrapper {
  display: none;
}

.canvas-wrapper {
  position: relative;
  height: 420px;
  padding: 16px;
}

/* Chart Tabs Row - contains tabs and filter */
.chart-tabs-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  gap: 16px;
}

/* Chart Tabs */

/* Dim filter (dropdown) */
.dim-filter {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-shrink: 0;
}

.dim-filter label{
  font-size: 12px;
  color: var(--text-secondary);
  white-space: nowrap;
}

.dim-select{
  min-width: 180px;
  max-width: 360px;
  padding: 6px 10px;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--card-bg);
  color: var(--text);
  font-size: 12px;
  outline: none;
}

.dim-select:focus{
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-light);
}

.dim-hint{
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 8px;
}

.chart-tabs {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  flex: 1;
}

.chart-tab {
  padding: 6px 14px;
  border-radius: 6px;
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s ease;
}

.chart-tab:hover {
  background: var(--card-bg);
  border-color: var(--accent-light);
  color: var(--accent);
}

.chart-tab.active {
  background: var(--accent-light);
  border-color: var(--accent);
  color: var(--accent-dark);
  font-weight: 600;
}

/* KPIå¡ç‰‡ */
.kpi-card {
  background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
  border-radius: var(--r2);
  padding: 32px;
  text-align: center;
  box-shadow: var(--shadow-lg);
  color: white;
}

.kpi-title {
  font-size: 13px;
  font-weight: 500;
  margin-bottom: 8px;
  opacity: 0.9;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.kpi-value {
  font-size: 48px;
  font-weight: 700;
  color: white;
  line-height: 1;
  text-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}
    .funnel-wrap{
      width:100%;
      height:220px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

/* ç©ºçŠ¶æ€ */
.empty-module {
  padding: 80px 20px;
  text-align: center;
  color: var(--text-muted);
  background: var(--border-light);
  border-radius: var(--r2);
}

.empty-module-icon {
  font-size: 48px;
  margin-bottom: 12px;
  opacity: 0.3;
}

/* åŠ¨ç”» */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.module-row {
  animation: fadeInUp 0.4s ease-out backwards;
}

.module-row:nth-child(1) { animation-delay: 0.05s; }
.module-row:nth-child(2) { animation-delay: 0.1s; }
.module-row:nth-child(3) { animation-delay: 0.15s; }
.module-row:nth-child(4) { animation-delay: 0.2s; }
.module-row:nth-child(5) { animation-delay: 0.25s; }
.module-row:nth-child(6) { animation-delay: 0.3s; }

/* Badge */
.badge {
  display: inline-flex;
  align-items: center;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  background: var(--accent-light);
  color: var(--accent-dark);
}

/* å“åº”å¼ */
@media (max-width: 768px) {
  .header {
    padding: 20px;
  }

  .header h1 {
    font-size: 24px;
  }

  .nav-tabs {
    padding-left: 16px;
    padding-right: 16px;
  }

  .container {
    padding: 16px;
  }

  .module-body {
    padding: 16px;
  }
}

/* ====== Layout: 3 charts per row ====== */
.charts-grid{
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 16px;
}
@media (max-width: 1200px){
  .charts-grid{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
}
@media (max-width: 780px){
  .charts-grid{ grid-template-columns: repeat(1, minmax(0, 1fr)); }
}

/* ====== Dim multi-select dropdown ====== */
.dim-filter{
  position: relative;
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: auto;
}
.dim-filter-label{
  font-size: 12px;
  color: var(--text-secondary);
  white-space: nowrap;
}
.dim-dd-btn{
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 6px 10px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: var(--card-bg);
  color: var(--text);
  font-size: 12px;
  cursor: pointer;
  user-select: none;
  max-width: 260px;
}
.dim-dd-btn:focus{
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-light);
}
.dim-dd-text{
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 200px;
}
.dim-dd-panel{
  position: absolute;
  right: 0;
  top: calc(100% + 8px);
  width: 320px;
  max-height: 360px;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--card-bg);
  box-shadow: 0 10px 30px rgba(0,0,0,0.10);
  z-index: 50;
  display: none;
  overflow: hidden;
}
.dim-dd-panel.open{ display: block; }
.dim-dd-search{
  width: 100%;
  padding: 10px 12px;
  border: none;
  border-bottom: 1px solid var(--border);
  background: transparent;
  color: var(--text);
  font-size: 12px;
  outline: none;
}
.dim-dd-list{
  padding: 8px 10px;
  overflow: auto;
  max-height: 280px;
}
.dim-dd-item{
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 6px;
  border-radius: 8px;
}
.dim-dd-item:hover{
  background: rgba(59,130,246,0.07);
}
.dim-dd-actions{
  display: flex;
  gap: 8px;
  padding: 10px;
  border-top: 1px solid var(--border);
}
.dim-dd-actions button{
  flex: 1;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--text);
  font-size: 12px;
  cursor: pointer;
}
.dim-dd-actions button.primary{
  border-color: var(--accent);
  background: var(--accent);
  color: white;
}

/* ====== Prevent label clipping ====== */
.canvas-wrapper{
  padding: 10px 8px 18px 8px;
}


/* ====== Card header refinements ====== */
.chart-header{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}
.latest-badge{
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  border-radius: 999px;
  border: 1px solid var(--accent-light);
  background: var(--accent-light);
  color: var(--accent-dark);
  font-size: 14px;
  font-weight: 800;
  letter-spacing: -0.01em;
  white-space: nowrap;
  box-shadow: 0 1px 0 rgba(0,0,0,0.04);
}
/* More breathing room so labels don't clip */
.canvas-wrapper{
  padding: 12px 10px 26px 10px;
}

</style>
</head>
<body>
<script type="application/json" id="charts-data">{
  "platform_basics": [],
  "user_growth": [],
  "revenue": [],
  "daily_challenge": [],
  "pk": [],
  "viral": [],
  "cash_out": [],
  "monitoring": [],
  "engagement": []
}</script>
<script type="application/json" id="ai-summary-data">"# KiX \u6307\u6807\u5206\u6790\u62a5\u544a\n**\u751f\u6210\u65f6\u95f4**: 2026-02-10 11:19\n\n## Platform Basics\n\n**dau**\n\n\u2022 \u73b0\u72b6\u4e0e\u76ee\u6807\uff1a\u5f53\u524d\u503c 443 / \u76ee\u6807\u503c 250 / \u5df2\u5b8c\u6210 77.2%\n\n\u2022 \u8d8b\u52bf\u5206\u6790\uff1a\u6700\u8fd1\u51e0\u5929DAU\u5448\u73b0\u6ce2\u52a8\u8d8b\u52bf\uff0c\u6700\u9ad8\u70b9\u4e3a549\uff082026-02-07\uff09\uff0c\u6700\u4f4e\u70b9\u4e3a117\uff082026-02-03\uff09\u3002\u73af\u6bd4\u53d8\u5316\u65b9\u9762\uff0c2026-02-08\u52302026-02-09\u589e\u957f\u4e8669.08%\uff0c\u663e\u793a\u51fa\u663e\u8457\u7684\u589e\u957f\u3002\n\n\u2022 \u6df1\u5ea6\u6d1e\u5bdf\uff1a\n1. \u65b0\u7528\u6237\uff08new_user\uff09\u57282026-02-09\u8fbe\u5230\u4e86275\uff0c\u8f83\u524d\u4e00\u5929\u7684126\u589e\u957f\u4e86118.25%\uff0c\u662fDAU\u589e\u957f\u7684\u4e3b\u8981\u9a71\u52a8\u529b\u3002\n2. D1\u7559\u5b58\u7387\u57282026-02-09\u964d\u81f34.36%\uff0c\u8f83\u524d\u4e00\u5929\u768417.46%\u5927\u5e45\u4e0b\u964d\uff0c\u53ef\u80fd\u5f71\u54cd\u4e86DAU\u7684\u53ef\u6301\u7eed\u6027\u3002\n3. \u8001\u7528\u6237\u6d3b\u8dc3\u5ea6\uff08DAU - \u65b0\u7528\u6237 - D1\u56de\u6d41\uff09\u5728\u6700\u8fd1\u51e0\u5929\u6ce2\u52a8\u8f83\u5927\uff0c2026-02-09\u7684\u8001\u7528\u6237\u6d3b\u8dc3\u5ea6\u4e3a165\uff08443 - 275 - 12\uff09\uff0c\u663e\u793a\u51fa\u8001\u7528\u6237\u7684\u6d3b\u8dc3\u5ea6\u4ecd\u9700\u63d0\u5347\u3002\n4. \u4e3b\u8981\u6765\u6e90\u5206\u6790\u663e\u793a\uff0c\"Organic\"\u6765\u6e90\u57282026-02-09\u8d21\u732e\u4e86275\u7684\u65b0\u7528\u6237\uff0c\u6210\u4e3a\u589e\u957f\u7684\u4e3b\u8981\u6765\u6e90\uff0c\u800c\"others\"\u6765\u6e90\u7684\u8d21\u732e\u76f8\u5bf9\u8f83\u5c0f\u3002\n5. \u6839\u636e\u5f53\u524d\u589e\u901f\uff0c\u82e5\u4fdd\u6301275\u7684\u65b0\u7528\u6237\u589e\u957f\uff0c\u9884\u8ba1\u5728\u7ea63\u5929\u5185\u53ef\u8fbe\u5230\u76ee\u6807DAU 250\uff0c\u9700\u5173\u6ce8D1\u7559\u5b58\u7387\u7684\u63d0\u5347\u4ee5\u786e\u4fdd\u53ef\u6301\u7eed\u589e\u957f\u3002"</script>


<div class="container">
  <div class="header">
    <h1>ğŸ“Š KiX server Dashboard</h1>
    <div class="header-info">
      <span>ğŸ“… Date: <strong id="dataPeriod">-</strong></span>
      <span style="margin-left:20px">ğŸ•’ Generated: <strong id="generatedAt">-</strong></span>
    </div>
  </div>

<nav class="nav-tabs" id="navTabs">
    <!-- å¯¼èˆªæŒ‰é’®ä¼šé€šè¿‡JSæ’å…¥åˆ°è¿™é‡Œ -->
</nav>

  <!-- æŒ‡æ ‡è¯¦æƒ…é¡µé¢åŒ…å±‘ -->
  <div class="metric-detail-breadcrumb" id="metricBreadcrumb" style="display: none;">
    <div class="breadcrumb-content">
      <button class="back-button" onclick="returnToAllMetrics()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
        <span>è¿”å›å…¨éƒ¨æŒ‡æ ‡</span>
      </button>
      <div class="breadcrumb-path">
        <span class="breadcrumb-item">å…¨éƒ¨æŒ‡æ ‡</span>
        <span class="breadcrumb-separator">â€º</span>
        <span class="breadcrumb-item current" id="currentMetricName">æŒ‡æ ‡è¯¦æƒ…</span>
      </div>
    </div>
  </div>

  <div class="content-layout" id="contentLayout">
  <div class="main-area">
    <div class="modules" id="modulesArea"></div>
  </div>

  <aside class="ai-panel" id="aiPanel" aria-label="AI Analysis Panel">
    <div class="ai-panel-header">
      <div class="ai-panel-title">
        <span class="ai-dot"></span>
        <span id="aiPanelTitle">AI åˆ†æ</span>
      </div>
      <div class="ai-panel-actions">
        <button class="ai-panel-btn" id="aiCollapseBtn" title="æŠ˜å ">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M15 18l-6-6 6-6"/>
          </svg>
        </button>
      </div>
    </div>
    <div class="ai-panel-subtitle" id="aiPanelSubtitle">ç‚¹å‡»ä»»æ„æŒ‡æ ‡å¡ç‰‡æŸ¥çœ‹å¯¹åº” AI åˆ†æ</div>
    <div class="ai-panel-content" id="aiSidebarContent"></div>
  </aside>

  <button class="ai-expand-handle" id="aiExpandBtn" title="å±•å¼€ AI">
    AI
  </button>
</div>
</div>

<script>
Chart.register(ChartDataLabels);


// =========================
// Global Chart.js aesthetics
// =========================
Chart.defaults.font.family = "-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,'Apple Color Emoji','Segoe UI Emoji'";
Chart.defaults.font.size = 11;
Chart.defaults.color = "#475569"; // slate-600
Chart.defaults.plugins.legend.labels.boxWidth = 10;
Chart.defaults.plugins.legend.labels.boxHeight = 10;
Chart.defaults.plugins.legend.labels.usePointStyle = true;
Chart.defaults.plugins.legend.labels.pointStyle = "circle";
Chart.defaults.plugins.tooltip.padding = 10;
Chart.defaults.plugins.tooltip.bodySpacing = 6;
Chart.defaults.plugins.tooltip.titleSpacing = 6;
Chart.defaults.plugins.tooltip.displayColors = true;

// çŸ­æ—¥æœŸæ ¼å¼åŒ–: å°† "2026-01-05" æˆ– "2026-01-05~2026-01-11" è½¬æ¢ä¸º "01-05"
function formatShortDate(dateStr) {
  if (!dateStr || typeof dateStr !== 'string') return dateStr;

  // å¦‚æœå·²ç»æ˜¯çŸ­æ ¼å¼ (MM-DD æˆ– MM)ï¼Œç›´æ¥è¿”å›
  if (/^\d{2}-\d{2}$/.test(dateStr) || /^\d{2}$/.test(dateStr)) {
    return dateStr;
  }

  // å¤„ç†å‘¨èŒƒå›´æ ¼å¼ "YYYY-MM-DD~YYYY-MM-DD"
  if (dateStr.includes('~')) {
    const parts = dateStr.split('~');
    dateStr = parts[0].trim(); // å–ç¬¬ä¸€ä¸ªæ—¥æœŸ
  }

  // åŒ¹é… YYYY-MM-DD æ ¼å¼
  const match = dateStr.match(/^\d{4}-(\d{2}-\d{2})/);
  if (match) {
    return match[1]; // è¿”å› MM-DD éƒ¨åˆ†
  }

  // å¤„ç†æœˆä»½æ ¼å¼ YYYY-MM
  const monthMatch = dateStr.match(/^\d{4}-(\d{2})$/);
  if (monthMatch) {
    return monthMatch[1]; // è¿”å› MM
  }

  return dateStr; // å…¶ä»–æ ¼å¼åŸæ ·è¿”å›
}

// Common axis tick formatting
function formatTick(v, kind, tab) {
  const percent = isPercentKind(kind) || isValueUnitPercent(tab);

  // å¦‚æœæ˜¯å­—ç¬¦ä¸²(å¯èƒ½æ˜¯æ—¥æœŸ),è¿›è¡Œæ—¥æœŸæ ¼å¼åŒ–
  if (typeof v === 'string') {
    return formatShortDate(v);
  }

  if (percent) return formatPercentValue(v, tab, 1);
  return formatNumberCompact(v, { decimals: 2, maxDigits: 6 });
}

function applyCommonScales(scales, kind) {
  // x
  if (scales.x) {
    scales.x.grid = scales.x.grid || {};
    scales.x.ticks = scales.x.ticks || {};
    scales.x.grid.display = false;
    scales.x.ticks.maxRotation = 0;
    scales.x.ticks.autoSkip = true;
    scales.x.ticks.padding = 6;
  }
  // y / y1
  ["y","y1"].forEach(k=>{
    if (!scales[k]) return;
    scales[k].ticks = scales[k].ticks || {};
    scales[k].ticks.padding = 6;
    scales[k].ticks.callback = (v)=>formatTick(v, kind);
    scales[k].grid = scales[k].grid || {};
    if (k === "y") scales[k].grid.color = "#eef2f7";
  });
}

// Compute latest value (for badge) â€” always interpret as "latest point", not sum
function getLatestValueFromTab(tab) {
  try {
    if (!tab || !tab.data) return null;

    // single value
    if (tab.kind === "single_value" && typeof tab.data.value === "number") return tab.data.value;

    // percent charts: show 100% (semantic "total")
    if (isPercentKind(tab.kind)) return 100;

    // time-series array: take last finite point (overall line/bar_line uses this)
    if (Array.isArray(tab.data.values) && tab.data.values.length) {
      for (let i = tab.data.values.length - 1; i >= 0; i--) {
        const v = Number(tab.data.values[i]);
        if (Number.isFinite(v)) return v;
      }
    }

    // matrix time-series: take last date row sum (fallback)
    if (Array.isArray(tab.data.matrix) && tab.data.matrix.length) {
      for (let i = tab.data.matrix.length - 1; i >= 0; i--) {
        const row = tab.data.matrix[i] || [];
        const nums = row.map(x => Number(x)).filter(x => Number.isFinite(x));
        if (nums.length) return nums.reduce((a,b)=>a+b, 0);
      }
    }

    // labels/values (doughnut etc.): treat as total
    if (Array.isArray(tab.data.values) && tab.data.values.length) {
      const nums = tab.data.values.map(x => Number(x)).filter(x => Number.isFinite(x));
      if (nums.length) return nums.reduce((a,b)=>a+b, 0);
    }

    return null;
  } catch (e) {
    return null;
  }
}


function updateLatestBadge(chartId, tab) {
  const el = document.getElementById("latest-" + chartId);
  if (!el) return;

  // ğŸ”¥ Funnel badge: æ˜¾ç¤ºç™¾åˆ†æ¯”è€Œä¸æ˜¯åˆ†æ•°å½¢å¼
  if (tab && tab.kind === "funnel" && tab.data && (tab.data.numerator !== undefined) && (tab.data.denominator !== undefined)) {
    const n = Number(tab.data.numerator ?? 0) || 0;
    const d = Number(tab.data.denominator ?? 0) || 0;
    const percentage = d > 0 ? ((n / d) * 100).toFixed(1) : '0.0';
    el.textContent = `${percentage}%`;
    return;
  }

  const v = getLatestValueFromTab(tab);
  if (v === null || v === undefined || Number.isNaN(v)) {
    el.textContent = "-";
    return;
  }

  const percent = isPercentTab(tab);
  if (percent) {
    el.textContent = formatPercentValue(v, tab, 1);
    return;
  }

  const num = Number(v);
  const abs = Math.abs(num);
  const decimals = abs < 1 ? 4 : 2;
  let s = num.toLocaleString(undefined, { maximumFractionDigits: decimals });
  s = s.replace(/(\.\d*?[1-9])0+$/, "$1").replace(/\.0+$/, "");
  el.textContent = s;
}

const CHARTS_BY_DOMAIN = JSON.parse(document.getElementById('charts-data').textContent);

const DOMAIN_TITLES = {
  "platform_basics": { name: "ğŸ—ï¸ Platform Basics", desc: "å¹³å°åŸºç¡€æŒ‡æ ‡" },
  "user_growth": { name: "ğŸ“ˆ User Growth", desc: "ç”¨æˆ·å¢é•¿æŒ‡æ ‡" },
  "revenue": { name: "ğŸ’° Revenue", desc: "æ”¶å…¥ç›¸å…³æŒ‡æ ‡" },
  "daily_challenge": { name: "ğŸ¯ Daily Challenge", desc: "æ¯æ—¥æŒ‘æˆ˜" },
  "pk": { name: "âš”ï¸ PK", desc: "PKå¯¹æˆ˜" },
  "viral": { name: "ğŸš€ Viral", desc: "ç—…æ¯’ä¼ æ’­" },
  "cash_out": { name: "ğŸ’¸ Cash out", desc: "æç°ç›¸å…³" },
  "monitoring": { name: "ğŸ“Š Monitoring", desc: "ç›‘æ§æŒ‡æ ‡" },
  "engagement": { name: "ğŸ® Engagement", desc: "ç”¨æˆ·å‚ä¸åº¦" }

};

const DEFAULT_TITLE = { name: "ğŸ“Š Other", desc: "å…¶ä»–æŒ‡æ ‡" };
const chartInstances = {};

// =========================
// Number formatting (compact)
// =========================
function trimDecimals(v, decimals) {
  if (decimals === 0) {
    // å½“decimals=0æ—¶ï¼Œç›´æ¥è¿”å›æ•´æ•°ï¼Œä¸ç”¨æ­£åˆ™å¤„ç†
    return Math.round(v).toString();
  }
  const s = Number(v).toFixed(decimals);
  // åªå¤„ç†å°æ•°éƒ¨åˆ†çš„æœ«å°¾0
  return s.replace(/\.?0+$/, "");
}

function formatNumberCompact(x, opts = {}) {
  const {
    maxDigits = 4,
    decimals = 1,  // é»˜è®¤ä»2æ”¹ä¸º1,æ›´ç®€æ´
    isPercent = false,
    unit = null,
  } = opts;

  if (x === null || x === undefined || Number.isNaN(x)) return "";
  let v = Number(x);

  if (isPercent) {
    // If input is ratio 0~1, convert to %
    if (Math.abs(v) <= 1) v = v * 100;
    const d = (decimals === null || decimals === undefined) ? 1 : decimals;
    let s = `${trimDecimals(v, d)}%`;
    return s;
  }

  const abs = Math.abs(v);
  let s = "";
  if (abs >= 1e9) s = `${trimDecimals(v / 1e9, 1)}B`;
  else if (abs >= 1e6) s = `${trimDecimals(v / 1e6, 1)}M`;
  else if (abs >= 1e3) s = `${trimDecimals(v / 1e3, 1)}K`;
  else if (abs >= 1) s = `${trimDecimals(v, 0)}`; // æ•´æ•°ä¸æ˜¾ç¤ºå°æ•°
  else s = `${trimDecimals(v, 2)}`; // å°äº1çš„æ•°å­—ä¿ç•™2ä½å°æ•°

  if (unit) s = `${s} ${unit}`;

  return s;
}

function isValueUnitPercent(tab) {
  return tab && tab.meta && String(tab.meta.value_unit || "").toLowerCase() === "percent";
}

function isPercentTab(tab) {
  return isPercentKind(tab.kind) || isValueUnitPercent(tab);
}

function formatPercentValue(value, tab, fallbackDecimals = 1) {
  if (value === null || value === undefined || Number.isNaN(value)) return "";
  let v = Number(value);
  if (Math.abs(v) <= 1) v = v * 100;
  const d = Math.max(1, (fallbackDecimals === null || fallbackDecimals === undefined) ? 1 : fallbackDecimals);
  return `${trimDecimals(v, d)}%`;
}

function renderFunnel(containerSelector, tab, spec) {
  const el = document.querySelector(containerSelector);
  if (!el) return;

  const data = tab.data || {};

  // ä» metric_id è§£æ layer åç§°
  let layer1Name = "Layer 1 (denominator)";
  let layer2Name = "Layer 2 (numerator)";

  if (spec && spec.metric_id && spec.metric_id.includes('_to_')) {
    const parts = spec.metric_id.split('_to_');
    if (parts.length === 2) {
      layer1Name = parts[0].replace(/_/g, ' ');
      layer2Name = parts[1].replace(/_/g, ' ');
    }
  }

  // ğŸ”¥ å› ä¸ºfunnelåªæ”¯æŒå•é€‰ç»´åº¦å€¼ï¼Œæ‰€ä»¥è¿™é‡Œç®€åŒ–å¤„ç†
  // æ£€æŸ¥æ˜¯å¦æ˜¯å¤šç»´åº¦æ•°æ®ï¼ˆæœ‰dim_labelsæ•°ç»„ï¼‰
  let layer1, layer2, title;

  if (Array.isArray(data.dim_labels) && data.dim_labels.length > 0) {
    // æœ‰ç»´åº¦æ•°æ®ï¼šå–ç¬¬ä¸€ä¸ªï¼ˆå› ä¸ºå•é€‰åªä¼šæœ‰ä¸€ä¸ªï¼‰
    layer1 = Number(data.denominator[0] ?? 0) || 0;
    layer2 = Number(data.numerator[0] ?? 0) || 0;
    title = data.dim_labels[0];
  } else {
    // Overallæ•°æ®
    layer1 = Number(data.denominator ?? 0) || 0;
    layer2 = Number(data.numerator ?? 0) || 0;
    title = tab.tab_label || "Funnel";
  }

  const W = Math.max(260, el.clientWidth || 360);
  const H = Math.max(180, el.clientHeight || 220);

  d3.select(el).html("");
  renderSingleFunnel(d3.select(el), title, layer1, layer2, layer1Name, layer2Name, W, H);
}

function renderSingleFunnel(container, title, layer1, layer2, layer1Name, layer2Name, W, H) {
  const pad = 14;
  const barH = 46; // å¢åŠ æŸ±å­é«˜åº¦ä»¥å®¹çº³æ–‡å­—
  const gap = 24; // å¢åŠ é—´è·

  const svg = container.append("svg")
    .attr("width", W)
    .attr("height", H)
    .attr("viewBox", `0 0 ${W} ${H}`)
    .style("flex-shrink", "0");

  const maxV = Math.max(layer1, layer2, 1);
  const w1 = (W - pad*2) * (layer1 / maxV);
  const w2 = (W - pad*2) * (layer2 / maxV);

  // Bars (centered)
  const x1 = (W - w1) / 2;
  const x2 = (W - w2) / 2;

  const y1 = 50; // æ ‡é¢˜ä¸‹æ–¹ç•™æ›´å¤šç©ºé—´
  const y2 = y1 + barH + gap;

  // Background rails
  svg.append("rect")
    .attr("x", pad).attr("y", y1)
    .attr("width", W - pad*2).attr("height", barH)
    .attr("rx", 10).attr("fill", "#f2f5fa");

  svg.append("rect")
    .attr("x", pad).attr("y", y2)
    .attr("width", W - pad*2).attr("height", barH)
    .attr("rx", 10).attr("fill", "#f2f5fa");

  // Filled bars with gradient
  const gradient1 = svg.append("defs").append("linearGradient")
    .attr("id", `grad1-${Math.random().toString(36).substr(2, 9)}`)
    .attr("x1", "0%").attr("y1", "0%")
    .attr("x2", "100%").attr("y2", "0%");
  gradient1.append("stop").attr("offset", "0%").attr("style", "stop-color:#6c5ce7;stop-opacity:1");
  gradient1.append("stop").attr("offset", "100%").attr("style", "stop-color:#a29bfe;stop-opacity:1");

  const gradient2 = svg.append("defs").append("linearGradient")
    .attr("id", `grad2-${Math.random().toString(36).substr(2, 9)}`)
    .attr("x1", "0%").attr("y1", "0%")
    .attr("x2", "100%").attr("y2", "0%");
  gradient2.append("stop").attr("offset", "0%").attr("style", "stop-color:#00b894;stop-opacity:1");
  gradient2.append("stop").attr("offset", "100%").attr("style", "stop-color:#55efc4;stop-opacity:1");

  svg.append("rect")
    .attr("x", x1).attr("y", y1)
    .attr("width", w1).attr("height", barH)
    .attr("rx", 10)
    .attr("fill", `url(#${gradient1.attr("id")})`);

  svg.append("rect")
    .attr("x", x2).attr("y", y2)
    .attr("width", w2).attr("height", barH)
    .attr("rx", 10)
    .attr("fill", `url(#${gradient2.attr("id")})`);

  // Title with percentage (top)
  const badgePct = layer1 ? ((layer2 / layer1) * 100).toFixed(1) : '0.0';
  svg.append("text")
    .attr("x", W / 2)
    .attr("y", 28)
    .attr("text-anchor", "middle")
    .attr("fill", "#111")
    .attr("font-size", 14)
    .attr("font-weight", 700)
    .text(title);

  svg.append("text")
    .attr("x", W / 2)
    .attr("y", 42)
    .attr("text-anchor", "middle")
    .attr("fill", "#6b7280")
    .attr("font-size", 11)
    .attr("font-weight", 500)
    .text(`è½¬åŒ–ç‡: ${badgePct}%`);

  const fmtInt = (v) => {
    try { return Number(v || 0).toLocaleString(undefined, { maximumFractionDigits: 0 }); }
    catch(e) { return String(v || 0); }
  };

  // ğŸ”¥ Layeråç§°ç›´æ¥æ”¾åœ¨æŸ±å­å·¦ä¾§å†…éƒ¨
  svg.append("text")
    .attr("x", x1 + 12)
    .attr("y", y1 + barH/2 + 5)
    .attr("fill", "#000")
    .attr("font-size", 12)
    .attr("font-weight", 700)
    .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
    .text(layer1Name);

  svg.append("text")
    .attr("x", x2 + 12)
    .attr("y", y2 + barH/2 + 5)
    .attr("fill", "#000")
    .attr("font-size", 12)
    .attr("font-weight", 700)
    .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
    .text(layer2Name);

  // æ•°å€¼æ”¾åœ¨æŸ±å­å³ä¾§
  svg.append("text")
    .attr("x", x1 + w1 - 12)
    .attr("y", y1 + barH/2 + 5)
    .attr("text-anchor", "end")
    .attr("fill", "#000")
    .attr("font-size", 14)
    .attr("font-weight", 700)
    .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
    .text(fmtInt(layer1));

  svg.append("text")
    .attr("x", x2 + w2 - 12)
    .attr("y", y2 + barH/2 + 5)
    .attr("text-anchor", "end")
    .attr("fill", "#000")
    .attr("font-size", 14)
    .attr("font-weight", 700)
    .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
    .text(fmtInt(layer2));

  // Arrow + rate in center
  const midY = y1 + barH + gap/2;

  // ç»˜åˆ¶ç®­å¤´
  svg.append("defs").append("marker")
    .attr("id", `arrowhead-${Math.random().toString(36).substr(2, 9)}`)
    .attr("markerWidth", 10)
    .attr("markerHeight", 10)
    .attr("refX", 9)
    .attr("refY", 3)
    .attr("orient", "auto")
    .append("polygon")
    .attr("points", "0 0, 10 3, 0 6")
    .attr("fill", "#94a3b8");

  svg.append("line")
    .attr("x1", W/2)
    .attr("y1", y1 + barH + 4)
    .attr("x2", W/2)
    .attr("y2", y2 - 4)
    .attr("stroke", "#94a3b8")
    .attr("stroke-width", 3)
    .attr("stroke-linecap", "round")
    .attr("marker-end", `url(#${svg.select("marker").attr("id")})`);

  // è½¬åŒ–ç‡èƒŒæ™¯åœ†
  const rate = layer1 ? (layer2 / layer1) : 0;
  const ratePct = (Math.abs(rate) <= 1 ? rate*100 : rate);
  const rateText = (Math.round(ratePct*10)/10).toString().replace(/\.0$/, "") + "%";

  svg.append("circle")
    .attr("cx", W/2)
    .attr("cy", midY)
    .attr("r", 20)
    .attr("fill", "#fff")
    .attr("stroke", "#e2e8f0")
    .attr("stroke-width", 2);

  svg.append("text")
    .attr("x", W/2)
    .attr("y", midY + 5)
    .attr("text-anchor", "middle")
    .attr("fill", "#3b82f6")
    .attr("font-size", 13)
    .attr("font-weight", 800)
    .text(rateText);
}

function isPercentKind(kind) {
  return ["stacked100", "stacked100_area", "horizontal_percent_bar", "doughnut", "funnel"].includes(kind);
}

// =========================
// Dim filter state
// =========================
const selectedDimsState = {}; // key: chartId-tabId -> [dimLabels]

function dimStateKey(chartId, tabId) {
  return `${chartId}::${tabId}`;
}

function getDefaultTopDims(tab, topN = 5) {
  // Prefer ranked dims (sorted by latest value), then selected_dim_values, then all_dim_values
  const ranked = (tab.ranked_dim_values || []).filter(x => x !== null && x !== undefined && String(x).trim() !== "");
  if (ranked.length) return ranked.slice(0, topN);

  const sel = (tab.selected_dim_values || []).filter(x => x !== null && x !== undefined && String(x).trim() !== "");
  if (sel.length) return sel.slice(0, topN);

  const all = (tab.all_dim_values || []).filter(x => x !== null && x !== undefined && String(x).trim() !== "");
  return all.slice(0, topN);
}

function filterTabData(tab, selectedDims) {
  const t = JSON.parse(JSON.stringify(tab));
  if (!selectedDims || !selectedDims.length) return t;
  // Funnel (latest snapshot, possibly with dim_labels arrays)
  if (t.kind === "funnel" && t.data) {
    // by-dim funnel payload: {dim_labels, denominator, numerator, values}
    if (Array.isArray(t.data.dim_labels)) {
      const keep = t.data.dim_labels
        .map((l, i) => ({ l, i }))
        .filter(x => selectedDims.includes(x.l))
        .map(x => x.i);

      if (!keep.length) return t;

      // ğŸ”¥ funnelåªæ”¯æŒå•é€‰ï¼Œæ‰€ä»¥åªä¿ç•™ç¬¬ä¸€ä¸ªé€‰ä¸­çš„ç»´åº¦å€¼æ•°æ®
      const idx = keep[0];
      t.data = {
        date: t.data.date,
        dim_labels: [t.data.dim_labels[idx]],
        denominator: [t.data.denominator[idx]],
        numerator: [t.data.numerator[idx]],
        values: [t.data.values[idx]]
      };
      return t;
    }
    return t;
  }

  // Pie-like charts
  if (t.data && Array.isArray(t.data.labels) && Array.isArray(t.data.values)) {
    const idx = t.data.labels.map((l, i) => ({ l, i }))
      .filter(x => selectedDims.includes(x.l))
      .map(x => x.i);
    t.data.labels = idx.map(i => t.data.labels[i]);
    t.data.values = idx.map(i => t.data.values[i]);
    return t;
  }

  // Matrix-like charts (time series with multiple dimension series)
  if (t.data && Array.isArray(t.data.series) && Array.isArray(t.data.matrix) && Array.isArray(t.data.dates)) {
    const keepIdx = t.data.series
      .map((s, i) => ({ s, i }))
      .filter(x => selectedDims.includes(x.s))
      .map(x => x.i);

    t.data.series = keepIdx.map(i => t.data.series[i]);
    t.data.matrix = t.data.matrix.map(row => keepIdx.map(i => row[i] ?? 0));

    // âœ… è£æ‰â€œå‰é¢å…¨æ˜¯ 0/ç©ºâ€çš„æ—¥æœŸæ®µï¼šä»é€‰ä¸­ç»´åº¦çœŸæ­£å¼€å§‹æœ‰æ•°æ®çš„é‚£ä¸€å¤©èµ·å±•ç¤º
    let first = 0;
    for (let r = 0; r < t.data.matrix.length; r++) {
      const row = t.data.matrix[r] || [];
      const hasData = row.some(v => v !== null && v !== undefined && !Number.isNaN(v) && Number(v) !== 0);
      if (hasData) { first = r; break; }
      first = r + 1;
    }
    if (first > 0 && first < t.data.matrix.length) {
      t.data.dates = t.data.dates.slice(first);
      t.data.matrix = t.data.matrix.slice(first);
    }

    return t;
  }

  return t;
}

function setupDimDropdown(chartId, tab) {
  const canvas = document.getElementById("canvas-" + chartId);
  if (!canvas) return null;

  const card = canvas.closest(".chart-card");
  if (!card) return null;

  const box = card.querySelector(".dim-filter");
  const selectEl = card.querySelector("select.dim-select");
  const hint = card.querySelector(".dim-hint");
  if (!box || !selectEl) return null;

  if (!tab.filterable) {
    box.style.display = "none";
    if (hint) hint.style.display = "none";
    return null;
  }

  box.style.display = "flex";
  box.style.alignItems = "center";
  if (hint) hint.style.display = "block";

  const options = (tab.ranked_dim_values && tab.ranked_dim_values.length)
    ? tab.ranked_dim_values
    : (tab.all_dim_values && tab.all_dim_values.length)
      ? tab.all_dim_values
      : (tab.data && tab.data.series && tab.data.series.length)
        ? tab.data.series
        : (tab.data && tab.data.labels && tab.data.labels.length)
          ? tab.data.labels
          : [];

  selectEl.innerHTML = "";
  for (const d of options) {
    const opt = document.createElement("option");
    opt.value = d;
    opt.textContent = d;
    selectEl.appendChild(opt);
  }

  const key = dimStateKey(chartId, tab.tab_id);
  if (!selectedDimsState[key] || !selectedDimsState[key].length) {
    selectedDimsState[key] = tab.selected_dim_values || getDefaultTopDims(tab, 1);
  }
  const current = new Set(selectedDimsState[key]);
  for (const opt of selectEl.options) opt.selected = current.has(opt.value);

  return selectEl;
}

function getSelectedDims(selectEl) {
  return Array.from(selectEl.selectedOptions).map(o => o.value);
}




// =========================
// Dim filter dropdown (search + checkbox multi-select)
// =========================
function setupDimDropdownV3(chartId, tab, onApply) {
  const canvas = document.getElementById("canvas-" + chartId);
  if (!canvas) return null;
  const card = canvas.closest(".chart-card");
  if (!card) return null;

  const box = card.querySelector(".dim-filter");
  if (!box) return null;

  const btn = box.querySelector(".dim-dd-btn");
  const btnText = box.querySelector(".dim-dd-text");
  const panel = box.querySelector(".dim-dd-panel");
  const search = box.querySelector(".dim-dd-search");
  const list = box.querySelector(".dim-dd-list");
  const btnClear = box.querySelector(".dim-dd-clear");
  const btnApply = box.querySelector(".dim-dd-apply");

  if (!btn || !btnText || !panel || !search || !list || !btnClear || !btnApply) return null;

  if (!tab.filterable) {
    box.style.display = "none";
    return null;
  }
  box.style.display = "flex";

  const options = (tab.ranked_dim_values && tab.ranked_dim_values.length)
    ? tab.ranked_dim_values
    : (tab.all_dim_values && tab.all_dim_values.length)
      ? tab.all_dim_values
      : (tab.data && tab.data.series && tab.data.series.length)
        ? tab.data.series
        : (tab.data && tab.data.labels && tab.data.labels.length)
          ? tab.data.labels
          : [];

  const key = dimStateKey(chartId, tab.tab_id);
  if (!selectedDimsState[key] || !selectedDimsState[key].length) {
    selectedDimsState[key] = tab.selected_dim_values || getDefaultTopDims(tab, 1);
  }

  // ğŸ”¥ æ£€æŸ¥æ˜¯å¦ä¸ºfunnelç±»å‹ï¼Œfunnelåªèƒ½å•é€‰
  const isFunnelType = tab.kind === "funnel";

  function updateBtnText() {
    const n = (selectedDimsState[key] || []).length;
    btnText.textContent = n ? `å·²é€‰ ${n}` : "æœªé€‰æ‹©";
  }

  function renderList(filterText="") {
    const ft = (filterText || "").toLowerCase().trim();
    list.innerHTML = "";
    const selected = new Set(selectedDimsState[key] || []);
    const filtered = ft ? options.filter(x => String(x).toLowerCase().includes(ft)) : options;

    // ğŸ”¥ ä¸ºfunnelç±»å‹æ„å»ºç»´åº¦å€¼->ç™¾åˆ†æ¯”çš„æ˜ å°„
    let dimPercentMap = {};
    if (isFunnelType && tab.data && Array.isArray(tab.data.dim_labels)) {
      tab.data.dim_labels.forEach((label, idx) => {
        const denom = Number(tab.data.denominator?.[idx] ?? 0) || 0;
        const numer = Number(tab.data.numerator?.[idx] ?? 0) || 0;
        const pct = denom > 0 ? ((numer / denom) * 100).toFixed(1) : '0.0';
        dimPercentMap[label] = pct;
      });
    }

    for (const d of filtered) {
      const row = document.createElement("label");
      row.className = "dim-dd-item";
      row.style.display = "flex";
      row.style.justifyContent = "space-between";
      row.style.alignItems = "center";
      row.style.gap = "8px";

      const leftPart = document.createElement("div");
      leftPart.style.display = "flex";
      leftPart.style.alignItems = "center";
      leftPart.style.gap = "8px";
      leftPart.style.flex = "1";

      const cb = document.createElement("input");

      // ğŸ”¥ funnelç±»å‹ä½¿ç”¨radioå•é€‰ï¼Œå…¶ä»–ç±»å‹ä½¿ç”¨checkboxå¤šé€‰
      cb.type = isFunnelType ? "radio" : "checkbox";
      cb.name = isFunnelType ? `funnel-${key}` : undefined; // radioéœ€è¦nameåˆ†ç»„
      cb.value = d;
      cb.checked = selected.has(d);

      cb.onchange = () => {
        if (isFunnelType) {
          // ğŸ”¥ funnelå•é€‰ï¼šåªä¿ç•™å½“å‰é€‰ä¸­çš„ä¸€ä¸ª
          selectedDimsState[key] = cb.checked ? [d] : [];
        } else {
          // å¤šé€‰ï¼šåŸæœ‰é€»è¾‘
          const s = new Set(selectedDimsState[key] || []);
          if (cb.checked) s.add(d); else s.delete(d);
          selectedDimsState[key] = Array.from(s);
        }
        updateBtnText();

        // ğŸ”¥ funnelå•é€‰æ—¶éœ€è¦é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥æ›´æ–°radioçŠ¶æ€
        if (isFunnelType) {
          renderList(filterText);
        }
      };

      const text = document.createElement("span");
      text.textContent = d;
      text.style.fontSize = "12px";
      text.style.color = "var(--text)";
      text.style.flex = "1";

      leftPart.appendChild(cb);
      leftPart.appendChild(text);
      row.appendChild(leftPart);

      // ğŸ”¥ funnelç±»å‹ï¼šåœ¨å³ä¾§æ˜¾ç¤ºç™¾åˆ†æ¯”
      if (isFunnelType && dimPercentMap[d] !== undefined) {
        const pctSpan = document.createElement("span");
        pctSpan.textContent = dimPercentMap[d] + '%';
        pctSpan.style.fontSize = "11px";
        pctSpan.style.color = "#6b7280";
        pctSpan.style.fontWeight = "500";
        pctSpan.style.minWidth = "45px";
        pctSpan.style.textAlign = "right";
        row.appendChild(pctSpan);
      }

      list.appendChild(row);
    }
  }

  function closePanel(){ panel.classList.remove("open"); }
  function openPanel(){
    panel.classList.add("open");
    search.value = "";
    renderList("");
    updateBtnText();
    setTimeout(()=>search.focus(), 0);
  }

  btn.onclick = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (panel.classList.contains("open")) closePanel(); else openPanel();
  };

  document.addEventListener("click", (e) => {
    if (!panel.classList.contains("open")) return;
    if (!box.contains(e.target)) closePanel();
  });

  search.oninput = () => renderList(search.value);

  btnClear.onclick = (e) => {
    e.preventDefault();
    selectedDimsState[key] = [];
    renderList(search.value);
    updateBtnText();
  };

  btnApply.onclick = (e) => {
    e.preventDefault();
    const selected = (selectedDimsState[key] && selectedDimsState[key].length) ? selectedDimsState[key] : (tab.selected_dim_values || getDefaultTopDims(tab, 1));
    selectedDimsState[key] = selected;
    updateBtnText();
    closePanel();
    if (typeof onApply === "function") onApply(selected);
  };

  updateBtnText();
  renderList("");
  return { key };
}

// Chart.js é…è‰²æ–¹æ¡ˆ - ç™½è‰²ä¸»é¢˜
const COLORS = [
  '#3b82f6', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444',
  '#06b6d4', '#ec4899', '#14b8a6', '#f97316', '#6366f1'
];

const COLORS_ALPHA = COLORS.map(c => c + '20'); // é€æ˜åº¦20%

// é»˜è®¤Chart.jsé…ç½®
Chart.defaults.color = '#6b7280';
Chart.defaults.borderColor = '#e5e7eb';
Chart.defaults.font.family = '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
Chart.defaults.plugins.legend.labels.usePointStyle = true;
Chart.defaults.plugins.legend.labels.padding = 15;
Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(31, 41, 55, 0.95)';
Chart.defaults.plugins.tooltip.titleColor = '#fff';
Chart.defaults.plugins.tooltip.bodyColor = '#e5e7eb';
Chart.defaults.plugins.tooltip.borderColor = '#374151';
Chart.defaults.plugins.tooltip.borderWidth = 1;
Chart.defaults.plugins.tooltip.padding = 12;
Chart.defaults.plugins.tooltip.cornerRadius = 8;

// åˆå§‹åŒ–å¯¼èˆª
function initNavigation() {
  const navTabs = document.getElementById("navTabs");
  const domains = Object.keys(DOMAIN_TITLES);

  // å…ˆæ·»åŠ æ‰€æœ‰å¯¼èˆªæŒ‰é’®
  domains.forEach((domainId, index) => {
    const info = DOMAIN_TITLES[domainId] || DEFAULT_TITLE;
    const btn = document.createElement("button");
    btn.className = "nav-tab" + (index === 0 ? " active" : "");
    btn.textContent = info.name;
    btn.dataset.domain = domainId;
    btn.onclick = () => scrollToModule(domainId);
    navTabs.appendChild(btn);
  });

  // æœ€åæ·»åŠ æœç´¢æ¡†ï¼ˆæ”¾åœ¨å³ä¾§ï¼‰
  const searchContainer = document.createElement("div");
  searchContainer.className = "search-container";
  searchContainer.innerHTML = `
    <input 
      type="text" 
      id="metricSearch" 
      class="metric-search-input" 
      placeholder="ğŸ” æœç´¢æŒ‡æ ‡..."
      autocomplete="off"
    />
    <div class="search-results" id="searchResults"></div>
  `;
  navTabs.appendChild(searchContainer);

  // åˆå§‹åŒ–æœç´¢åŠŸèƒ½
  initMetricSearch();
}

// ğŸ” åˆå§‹åŒ–æŒ‡æ ‡æœç´¢åŠŸèƒ½
function initMetricSearch() {
  const searchInput = document.getElementById("metricSearch");
  const searchResults = document.getElementById("searchResults");

  if (!searchInput || !searchResults) {
    console.warn("æœç´¢æ¡†å…ƒç´ æœªæ‰¾åˆ°");
    return;
  }

  // æ„å»ºæ‰€æœ‰æŒ‡æ ‡çš„ç´¢å¼•
  const allMetrics = [];
  try {
    Object.entries(CHARTS_BY_DOMAIN).forEach(([domain, charts]) => {
      const domainInfo = DOMAIN_TITLES[domain] || DEFAULT_TITLE;
      if (charts && Array.isArray(charts)) {
        charts.forEach(chart => {
          if (chart && chart.chart_id && chart.title) {
            allMetrics.push({
              chartId: chart.chart_id,
              title: chart.title,
              domain: domain,
              domainName: domainInfo.name,
              metricId: chart.metric_id || ""
            });
          }
        });
      }
    });
    console.log(`âœ“ æœç´¢ç´¢å¼•å·²æ„å»ºï¼Œå…± ${allMetrics.length} ä¸ªæŒ‡æ ‡`);
  } catch (err) {
    console.error("æ„å»ºæœç´¢ç´¢å¼•å¤±è´¥:", err);
    return;
  }

  let searchTimeout;

  searchInput.addEventListener("input", (e) => {
    clearTimeout(searchTimeout);
    const query = e.target.value.trim();

    if (!query) {
      searchResults.classList.remove("show");
      searchResults.innerHTML = "";
      return;
    }

    // å»¶è¿Ÿæœç´¢ä»¥ä¼˜åŒ–æ€§èƒ½
    searchTimeout = setTimeout(() => {
      performSearch(query, allMetrics, searchResults);
    }, 200);
  });

  // ç‚¹å‡»å¤–éƒ¨å…³é—­æœç´¢ç»“æœ
  document.addEventListener("click", (e) => {
    if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
      searchResults.classList.remove("show");
    }
  });

  searchInput.addEventListener("focus", () => {
    if (searchInput.value.trim() && searchResults.innerHTML) {
      searchResults.classList.add("show");
    }
  });

  // æ”¯æŒEnteré”®é€‰æ‹©ç¬¬ä¸€ä¸ªç»“æœ
  searchInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      const firstItem = searchResults.querySelector(".search-result-item");
      if (firstItem) {
        firstItem.click();
      }
    }
  });
}

// æ‰§è¡Œæœç´¢
function performSearch(query, allMetrics, searchResults) {
  const lowerQuery = query.toLowerCase();

  // æ¨¡ç³ŠåŒ¹é…ï¼šæ ‡é¢˜æˆ–metric_idåŒ…å«æŸ¥è¯¢è¯
  const matches = allMetrics.filter(metric => {
    const titleMatch = metric.title.toLowerCase().includes(lowerQuery);
    const idMatch = metric.metricId.toLowerCase().includes(lowerQuery);
    return titleMatch || idMatch;
  });

  if (matches.length === 0) {
    searchResults.innerHTML = '<div class="search-no-results">æœªæ‰¾åˆ°åŒ¹é…çš„æŒ‡æ ‡</div>';
    searchResults.classList.add("show");
    return;
  }

  // é™åˆ¶æ˜¾ç¤ºå‰10ä¸ªç»“æœ
  const topMatches = matches.slice(0, 10);

  searchResults.innerHTML = topMatches.map(metric => `
    <div class="search-result-item" data-chart-id="${metric.chartId}">
      <div class="search-result-title">${highlightMatch(metric.title, query)}</div>
      <div class="search-result-domain">${metric.domainName}</div>
    </div>
  `).join("");

  searchResults.classList.add("show");

  // ç»‘å®šç‚¹å‡»äº‹ä»¶
  searchResults.querySelectorAll(".search-result-item").forEach(item => {
    item.addEventListener("click", () => {
      const chartId = item.dataset.chartId;
      scrollToAndHighlightChart(chartId);
      searchResults.classList.remove("show");
      document.getElementById("metricSearch").value = "";
    });
  });
}

// é«˜äº®åŒ¹é…çš„æ–‡æœ¬
function highlightMatch(text, query) {
  if (!text || !query) return text;

  const lowerText = text.toLowerCase();
  const lowerQuery = query.toLowerCase();
  const index = lowerText.indexOf(lowerQuery);

  if (index === -1) return text;

  const before = text.substring(0, index);
  const match = text.substring(index, index + query.length);
  const after = text.substring(index + query.length);

  return `${before}<mark style="background:#fef08a;color:#854d0e;padding:1px 3px;border-radius:3px;font-weight:600;">${match}</mark>${after}`;
}

// æ»šåŠ¨åˆ°æŒ‡å®šå›¾è¡¨å¹¶é«˜äº®
function scrollToAndHighlightChart(chartId) {
  // ç›´æ¥æŸ¥æ‰¾å¸¦æœ‰data-chart-idå±æ€§çš„chart-card
  const chartCard = document.querySelector(`.chart-card[data-chart-id="${chartId}"]`);

  if (!chartCard) {
    console.warn(`æœªæ‰¾åˆ°å›¾è¡¨: ${chartId}`);
    return;
  }

  // ç§»é™¤æ‰€æœ‰ç°æœ‰çš„é«˜äº®
  document.querySelectorAll(".chart-card.highlight").forEach(el => {
    el.classList.remove("highlight");
  });

  // æ»šåŠ¨åˆ°å›¾è¡¨
  chartCard.scrollIntoView({ behavior: "smooth", block: "center" });

  // æ·»åŠ é«˜äº®åŠ¨ç”»
  setTimeout(() => {
    chartCard.classList.add("highlight");
    console.log(`âœ“ é«˜äº®å›¾è¡¨: ${chartId}`);

    // 3ç§’åç§»é™¤é«˜äº®
    setTimeout(() => {
      chartCard.classList.remove("highlight");
    }, 3000);
  }, 500);
}

function scrollToModule(domainId) {
  const module = document.getElementById("module-" + domainId);
  if (module) {
    module.scrollIntoView({ behavior: "smooth", block: "start" });
    document.querySelectorAll(".nav-tab").forEach(btn => {
      btn.classList.toggle("active", btn.dataset.domain === domainId);
    });
  }
}

// åˆ›å»ºæ¨¡å—
function createModule(domain, charts) {
  const info = DOMAIN_TITLES[domain] || DEFAULT_TITLE;
  const chartCount = charts ? charts.length : 0;

  const module = document.createElement("article");
  module.className = "module-row";
  module.id = "module-" + domain;

  module.innerHTML = `
    <div class="module-header">
      <h2>${info.name}</h2>
      <p style="margin:4px 0 0;color:var(--muted);font-size:12px">${info.desc} Â· ${chartCount} ä¸ªå›¾è¡¨</p>
    </div>
    <div class="module-body">
      <div class="charts"></div>
    </div>
  `;

  return module;
}

// åˆ›å»ºå›¾è¡¨å¡ç‰‡
function createChartCard(spec) {
  const card = document.createElement("div");
  card.className = "chart-card";
  card.dataset.chartId = spec.chart_id; // æ·»åŠ chart-idå±æ€§ç”¨äºæœç´¢å®šä½
  card.dataset.metricId = spec.metric_id || ''; // æ·»åŠ metric-idå±æ€§

  // å¤„ç†tabbedç±»å‹
  if (spec.kind === "tabbed" && spec.tabs) {
    const firstTab = spec.tabs[0];

    // æ‰€æœ‰æŒ‡æ ‡éƒ½æ˜¾ç¤ºview detailsé“¾æ¥
    const viewDetailsLink = spec.metric_id ? `
      <div class="view-details-link-wrapper">
        <a class="view-details-link" onclick="onViewDetailsClick('${spec.metric_id}', event)" href="javascript:void(0);">
          view details â†’
        </a>
      </div>
    ` : '';

    // æ„å»ºmetricæè¿°è¡Œï¼ˆå¦‚æœæœ‰metric_idå’Œdescriptionï¼‰
    const metricInfo = (spec.metric_id && spec.description) ? `
      <div class="metric-info" style="font-size: 11px; color: #9ca3af; margin-top: 4px; line-height: 1.4;">
        ${spec.metric_id}: ${spec.description}
      </div>
    ` : '';

    card.innerHTML = `
      <div class="chart-header">
        <div>
          <div class="chart-title">${spec.title}${spec.has_ai ? `<span class="ai-badge" data-metric-id="${spec.metric_id}" title="AI åˆ†æ">AI</span>` : ``}</div>
          ${metricInfo}
        </div>
        <div class="chart-header-right">
          ${spec.hide_badge ? "" : `<div class="latest-badge" id="latest-${spec.chart_id}">-</div>`}
        </div>
      </div>
      <div class="chart-tabs-row">
        <div class="chart-tabs" id="tabs-${spec.chart_id}"></div>
        <div class="dim-filter" style="display:none;">
          <span class="dim-filter-label" style="font-size: 12px; color: #6b7280; margin-right: 6px;">ç­›é€‰:</span>
          <button class="dim-dd-btn" type="button">
            <span class="dim-dd-text">æœªé€‰æ‹©</span>
            <span>â–¾</span>
          </button>
          <div class="dim-dd-panel">
            <input class="dim-dd-search" type="text" placeholder="æœç´¢ç»´åº¦..." />
            <div class="dim-dd-list"></div>
            <div class="dim-dd-actions">
              <button class="dim-dd-clear" type="button">æ¸…ç©º</button>
              <button class="dim-dd-apply primary" type="button">åº”ç”¨</button>
            </div>
          </div>
        </div>
      </div>
      <div class="canvas-wrapper" style="height: 420px; padding: 16px;">
         <div class="funnel-wrap" id="funnel-${spec.chart_id}" style="display:none;"></div>
         <div class="kpi-wrap" id="kpi-${spec.chart_id}" style="display:none;"></div>
         <canvas id="canvas-${spec.chart_id}"></canvas>
       </div>
      <div class="dim-hint" style="display:none; margin-top: -8px; padding: 0 16px 12px; font-size: 11px; color: #9ca3af;">é»˜è®¤å±•ç¤ºTopç»´åº¦å€¼ï¼Œå¯å¤šé€‰åˆ‡æ¢</div>
      ${viewDetailsLink}
    `;

    // åˆ›å»ºtabs
    const tabsContainer = card.querySelector(".chart-tabs");
    spec.tabs.forEach((tab, idx) => {
      const btn = document.createElement("button");
      btn.className = "chart-tab" + (idx === 0 ? " active" : "");
      btn.textContent = tab.tab_label;
      btn.dataset.tabId = tab.tab_id;
      btn.dataset.chartId = spec.chart_id;
      btn.onclick = () => switchTab(spec, tab.tab_id);
      tabsContainer.appendChild(btn);
    });

    return card;
  }

  // æ™®é€šå›¾è¡¨
  const viewDetailsLink = spec.metric_id ? `
    <div class="view-details-link-wrapper">
      <a class="view-details-link" onclick="onViewDetailsClick('${spec.metric_id}', event)" href="javascript:void(0);">
        view details â†’
      </a>
    </div>
  ` : '';

  // æ„å»ºmetricæè¿°è¡Œï¼ˆå¦‚æœæœ‰metric_idå’Œdescriptionï¼‰
  const metricInfo = (spec.metric_id && spec.description) ? `
    <div class="metric-info" style="font-size: 11px; color: #9ca3af; margin-top: 4px; line-height: 1.4;">
      ${spec.metric_id}: ${spec.description}
    </div>
  ` : '';

  card.innerHTML = `
    <div class="chart-header">
      <div>
        <div class="chart-title">${spec.title}${spec.has_ai ? `<span class="ai-badge" data-metric-id="${spec.metric_id}" title="AI åˆ†æ">AI</span>` : ``}</div>
        ${metricInfo}
      </div>
    </div>
    <div class="canvas-wrapper">
      <canvas id="canvas-${spec.chart_id}"></canvas>
    </div>
    ${viewDetailsLink}
  `;

  // æ·»åŠ ç‚¹å‡»æ˜¾ç¤º AI åˆ†æçš„åŠŸèƒ½
  card.style.cursor = 'pointer';
  card.addEventListener('click', function(e) {
    if (!e.target.closest('a') && !e.target.closest('button') && !e.target.closest('.tab-button')) {
      showAIAnalysisForMetric(spec.metric_id, spec.title);
    }
  });

  return card;
}

function getOverallTabFromSpec(spec) {
  if (!spec || !Array.isArray(spec.tabs) || !spec.tabs.length) return null;
  return spec.tabs.find(t => t.tab_id === "overall") || spec.tabs[0];
}

// åˆ‡æ¢Tab
function switchTab(spec, tabId) {
  // æ›´æ–°æŒ‰é’®çŠ¶æ€
  document.querySelectorAll(`[data-chart-id="${spec.chart_id}"]`).forEach(btn => {
    btn.classList.toggle("active", btn.dataset.tabId === tabId);
  });

  const tab = spec.tabs.find(t => t.tab_id === tabId);
  if (!tab) return;

  // âœ… Badge æ°¸è¿œæ˜¾ç¤º overall çš„æœ€æ–°å€¼ï¼ˆåˆ‡åˆ°ç»´åº¦tabä¹Ÿä¸å˜ï¼‰
  const overallTab = getOverallTabFromSpec(spec);

  // ç»´åº¦ç­›é€‰ï¼ˆdropdown é¢æ¿ï¼‰
  setupDimDropdownV3(spec.chart_id, tab, (finalSelected) => {
    const key = dimStateKey(spec.chart_id, tab.tab_id);
    selectedDimsState[key] = finalSelected;

    const filtered = filterTabData(tab, finalSelected);

    // ä¸éšç»´åº¦å˜åŒ–
    updateLatestBadge(spec.chart_id, overallTab);

    renderTabChart(spec.chart_id, filtered);
  });

  // åˆæ¬¡æ¸²æŸ“ï¼šä½¿ç”¨Pythonç«¯ä¼ é€’çš„selected_dim_valuesä½œä¸ºé»˜è®¤å€¼
  let tabToRender = tab;
  if (tab.filterable) {
    const key = dimStateKey(spec.chart_id, tab.tab_id);
    const selected =
      (selectedDimsState[key] && selectedDimsState[key].length)
        ? selectedDimsState[key]
        : (tab.selected_dim_values || getDefaultTopDims(tab, 1));
    selectedDimsState[key] = selected;
    tabToRender = filterTabData(tab, selected);
  }

  // ä¸éš tab / ç»´åº¦å˜åŒ–
  updateLatestBadge(spec.chart_id, overallTab);

  renderTabChart(spec.chart_id, tabToRender);
}

// æ¸²æŸ“Tabå›¾è¡¨
function renderTabChart(chartId, tab) {
  const canvas = document.getElementById("canvas-" + chartId);
  if (!canvas) return;

  const ctx = canvas.getContext("2d");

  // é”€æ¯æ—§å›¾è¡¨
  if (chartInstances[chartId]) {
    chartInstances[chartId].destroy();
  }

  // reset containers (keep DOM stable)
  const funnelEl = document.getElementById("funnel-" + chartId);
  const kpiEl = document.getElementById("kpi-" + chartId);
  if (funnelEl) funnelEl.style.display = "none";
  if (kpiEl) kpiEl.style.display = "none";
  canvas.style.display = "block";

  let chart = null;

  switch(tab.kind) {
    case "single_value":
      // KPI: show in kpi container (keep DOM stable for tab switching)
      const wrap = canvas.parentElement;
      const kpiEl = document.getElementById("kpi-" + chartId);
      const funnelEl = document.getElementById("funnel-" + chartId);
      if (funnelEl) funnelEl.style.display = "none";
      if (canvas) canvas.style.display = "none";
      if (kpiEl) {
        kpiEl.style.display = "flex";
        kpiEl.innerHTML = `
          <div class="kpi-card">
            <div class="kpi-title">${tab.tab_label || 'å½“å‰å€¼'}</div>
            <div class="kpi-value">${isPercentTab(tab) ? formatPercentValue((tab.data.value || 0), tab, 1) : formatNumberCompact((tab.data.value || 0), {maxDigits: 6, decimals: 2})}</div>
          </div>
        `;
      }
      break;

    case "funnel":
      // Funnel: render into dedicated div (keep canvas for other tabs)
      const funnelEl2 = document.getElementById("funnel-" + chartId);
      const kpiEl2 = document.getElementById("kpi-" + chartId);
      if (kpiEl2) kpiEl2.style.display = "none";
      if (canvas) canvas.style.display = "none";
      if (funnelEl2) {
        funnelEl2.style.display = "flex";
        // éœ€è¦ä¼ é€’specæ¥è·å–metric_id
        const currentSpec = Object.values(CHARTS_BY_DOMAIN).flat().find(s => s.chart_id === chartId);
        renderFunnel(`#funnel-${chartId}`, tab, currentSpec);
      }
      break;

    case "line":
    case "bar_line":
      chart = new Chart(ctx, {
        type: "line",
        data: {
          labels: tab.data.dates,
          datasets: [{
            label: 'è¶‹åŠ¿',
            data: tab.data.values,
            borderColor: COLORS[0],
            backgroundColor: COLORS_ALPHA[0],
            tension: 0.4,
            fill: true,
            borderWidth: 2.5,
            pointRadius: 4,
            pointBackgroundColor: COLORS[0],
            pointBorderColor: '#fff',
            pointBorderWidth: 2,
            pointHoverRadius: 6
          }]
        },
        options: {
          layout: { padding: { top: 18, right: 14, bottom: 44, left: 8 } },
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            datalabels: {
              display: (ctx) => {
                const v = ctx.dataset.data?.[ctx.dataIndex];
                return v !== null && v !== undefined && !Number.isNaN(v) && v !== 0;
              },
              formatter: (value) => {
                if (value === null || value === undefined || Number.isNaN(value)) return "";
                const percent = isPercentTab(tab);
                if (percent) {
                  return formatPercentValue(value, tab, 1);
                }
                const num = Number(value);
                const abs = Math.abs(num);
                const decimals = abs < 1 ? 4 : 2;
                let s = num.toLocaleString(undefined, { maximumFractionDigits: decimals });
                s = s.replace(/(\.\d*?[1-9])0+$/, "$1").replace(/\.0+$/, "");
                return s;
              },
              clamp: true,
              clip: false,
              padding: 2,
              anchor: "end",
              align: (ctx) => (ctx.dataset.type === 'bar' ? 'top' : 'end'),
      offset: 6,
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const v = context.parsed && typeof context.parsed.y === "number" ? context.parsed.y : context.raw;
                  return 'å€¼: ' + (isPercentTab(tab) ? formatPercentValue(v, tab, 1) : formatNumberCompact(v, { decimals: 2, maxDigits: 8 }));
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              grid: {
                color: '#f3f4f6',
                drawBorder: false
              },
              ticks: {
                color: '#6b7280',
                padding: 8
              }
            },
            x: {
              grid: {
                display: false
              },
              ticks: {
                color: '#6b7280',
                padding: 8
              }
            }
          }
        }
      });
      break;

    case "grouped_bar":
      // åˆ†ç»„æŸ±çŠ¶å›¾
      const groupedDatasets = tab.data.series.map((name, idx) => ({
        label: name,
        data: tab.data.matrix.map(row => row[idx] || 0),
        backgroundColor: COLORS[idx % COLORS.length],
        borderColor: COLORS[idx % COLORS.length],
        borderWidth: 0,  // å»æ‰è¾¹æ¡†,æ›´ç°ä»£
        borderRadius: 4,  // æ·»åŠ åœ†è§’
        barPercentage: 0.85,  // å¢åŠ æŸ±å­å®½åº¦
        categoryPercentage: 0.75  // è°ƒæ•´åˆ†ç±»é—´è·
      }));

      chart = new Chart(ctx, {
        type: "bar",
        data: { labels: tab.data.dates, datasets: groupedDatasets },
        options: {
          layout: { padding: { top: 28, right: 14, bottom: 44, left: 8 } },  // å¢åŠ é¡¶éƒ¨paddingä»¥å®¹çº³æ ‡ç­¾
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          maintainAspectRatio: false,
          plugins: { 
            legend: { 
              display: true,
              position: 'top',
              align: 'end',
              labels: {
                usePointStyle: true,
                padding: 12,
                font: { size: 12 }
              }
            },
            datalabels: {
              display: (ctx) => {
                const v = ctx.dataset.data?.[ctx.dataIndex];
                return v !== null && v !== undefined && !Number.isNaN(v) && v !== 0;
              },
              formatter: (value) => {
                if (value === null || value === undefined || Number.isNaN(value)) return "";
                if (isPercentTab(tab)) return formatPercentValue(value, tab, 1);
                return formatNumberCompact(value, { decimals: 0, maxDigits: 5 });
              },
              anchor: 'end',
              align: 'top',
              offset: 2,
              clamp: true,
              font: { size: 10, weight: '500' },
              color: '#4b5563'
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                label: function(context) {
                  const v = context.parsed && typeof context.parsed.y === "number" ? context.parsed.y : context.raw;
                  return context.dataset.label + ': ' + (isPercentTab(tab) ? formatPercentValue(v, tab, 1) : formatNumberCompact(v, { decimals: 0, maxDigits: 8 }));
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              grid: {
                color: '#f3f4f6',
                drawBorder: false
              },
              ticks: { color: '#6b7280', callback: (v)=>formatTick(v, tab.kind, tab), padding: 6 }
            },
            x: {
              grid: {
                display: false
              },
              ticks: { 
                color: '#6b7280', 
                callback: function(value, index, ticks) {
                  // valueæ˜¯ç´¢å¼•ï¼Œéœ€è¦ä»labelsæ•°ç»„è·å–å®é™…æ ‡ç­¾
                  const label = this.getLabelForValue(value);
                  return formatShortDate(label);
                },
                padding: 6,
                maxRotation: 45,
                minRotation: 0
              }
            }
          }
        }
      });
      break;

    case "multi_line":
      // å¤šæŠ˜çº¿å›¾
      const multiLineDatasets = tab.data.series.map((name, idx) => ({
        label: name,
        data: tab.data.matrix.map(row => row[idx] || 0),
        borderColor: COLORS[idx % COLORS.length],
        backgroundColor: COLORS_ALPHA[idx % COLORS.length],
        borderWidth: 2.5,
        tension: 0.4,
        fill: false,
        pointRadius: 3,
        pointBackgroundColor: COLORS[idx % COLORS.length],
        pointBorderColor: '#fff',
        pointBorderWidth: 2
      }));

      chart = new Chart(ctx, {
        type: "line",
        data: { labels: tab.data.dates, datasets: multiLineDatasets },
        options: {
          layout: { padding: { top: 18, right: 14, bottom: 44, left: 8 } },
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          maintainAspectRatio: false,
          plugins: { 
            legend: { 
              display: true,
              position: 'top',
              align: 'end'
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                label: function(context) {
                  const v = context.parsed && typeof context.parsed.y === "number" ? context.parsed.y : context.raw;
                  return context.dataset.label + ': ' + (isPercentTab(tab) ? formatPercentValue(v, tab, 1) : formatNumberCompact(v, { decimals: 2, maxDigits: 8 }));
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              grid: {
                color: '#f3f4f6',
                drawBorder: false
              },
              ticks: { color: '#6b7280', callback: (v)=>formatTick(v, tab.kind, tab), padding: 6 }
            },
            x: {
              grid: {
                display: false
              },
              ticks: { 
                color: '#6b7280', 
                callback: function(value, index, ticks) {
                  const label = this.getLabelForValue(value);
                  return formatShortDate(label);
                },
                padding: 6,
                maxRotation: 45,
                minRotation: 0
              }
            }
          }
        }
      });
      break;

    case "stacked_area":
      // å †å é¢ç§¯å›¾
      const stackedDatasets = tab.data.series.map((name, idx) => ({
        label: name,
        data: tab.data.matrix.map(row => row[idx] || 0),
        borderColor: COLORS[idx % COLORS.length],
        backgroundColor: COLORS_ALPHA[idx % COLORS.length],
        borderWidth: 2,
        tension: 0.4,
        fill: true,
        pointRadius: 0
      }));

      chart = new Chart(ctx, {
        type: "line",
        data: { labels: tab.data.dates, datasets: stackedDatasets },
        options: {
          layout: { padding: { top: 18, right: 14, bottom: 44, left: 8 } },
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          maintainAspectRatio: false,
          plugins: { 
            legend: { 
              display: true,
              position: 'top',
              align: 'end'
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                label: function(context) {
                  const v = context.parsed && typeof context.parsed.y === "number" ? context.parsed.y : context.raw;
                  return context.dataset.label + ': ' + (isPercentTab(tab) ? formatPercentValue(v, tab, 1) : formatNumberCompact(v, { decimals: 2, maxDigits: 8 }));
                }
              }
            }
          },
          scales: {
            y: {
              stacked: true,
              beginAtZero: true,
              grid: {
                color: '#f3f4f6',
                drawBorder: false
              },
              ticks: { color: '#6b7280', callback: (v)=>formatTick(v, tab.kind, tab), padding: 6 }
            },
            x: {
              stacked: true,
              grid: {
                display: false
              },
              ticks: { 
                color: '#6b7280', 
                callback: function(value, index, ticks) {
                  const label = this.getLabelForValue(value);
                  return formatShortDate(label);
                },
                padding: 6,
                maxRotation: 45,
                minRotation: 0
              }
            }
          }
        }
      });
      break;

    case "doughnut":
      // ç¯å½¢å›¾
      const total = tab.data.values.reduce((a, b) => a + b, 0);
      chart = new Chart(ctx, {
        type: "doughnut",
        data: {
          labels: tab.data.labels,
          datasets: [{
            data: tab.data.values,
            backgroundColor: COLORS,
            borderColor: '#fff',
            borderWidth: 2
          }]
        },
        options: {
          layout: { padding: { top: 18, right: 14, bottom: 44, left: 8 } },
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'right',
              labels: {
                generateLabels: function(chart) {
                  const data = chart.data;
                  return data.labels.map((label, i) => {
                    const value = data.datasets[0].data[i];
                    const percent = ((value / total) * 100).toFixed(1);
                    return {
                      text: `${label}: ${percent}%`,
                      fillStyle: data.datasets[0].backgroundColor[i],
                      hidden: false,
                      index: i
                    };
                  });
                }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const value = context.parsed;
                  const percent = ((value / total) * 100).toFixed(1);
                  return `${context.label}: ${formatNumberCompact(value, {decimals: 2, maxDigits: 8})} (${percent}%)`;
                }
              }
            }
          }
        }
      });
      break;

    case "horizontal_percent_bar":
      // æ¨ªå‘ç™¾åˆ†æ¯”æ¡å½¢å›¾
      const hTotal = tab.data.values.reduce((a, b) => a + b, 0);
      const percentages = tab.data.values.map(v => (v / hTotal) * 100);

      chart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: tab.data.labels,
          datasets: [{
            data: percentages,
            backgroundColor: COLORS,
            borderColor: COLORS,
            borderWidth: 1
          }]
        },
        options: {
          layout: { padding: { top: 18, right: 14, bottom: 44, left: 8 } },
          indexAxis: 'y',
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${context.parsed.x.toFixed(1)}%`;
                }
              }
            }
          },
          scales: {
            x: {
              beginAtZero: true,
              max: 100,
              grid: {
                color: '#f3f4f6'
              },
              ticks: {
                callback: function(value) {
                  return value + '%';
                },
                color: '#6b7280'
              }
            },
            y: {
              grid: {
                display: false
              },
              ticks: { color: '#6b7280', callback: (v)=>formatTick(v, tab.kind, tab), padding: 6 }
            }
          }
        }
      });
      break;

    case "treemap":
      // çŸ©å½¢æ ‘å›¾ (ä½¿ç”¨D3.js)
      canvas.parentElement.innerHTML = `<div id="treemap-${chartId}" style="width:100%;height:320px"></div>`;
      renderTreemap(chartId, tab.data);
      break;

    case "grouped_bar_line":
      // æŸ±çŠ¶å›¾+æŠ˜çº¿å›¾ç»„åˆ
      const barData = tab.data.series[0];
      const lineData = tab.data.series[1] || tab.data.series[0];

      chart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: tab.data.dates,
          datasets: [
            {
              type: 'bar',
              label: barData,
              data: tab.data.matrix.map(row => row[0] || 0),
              backgroundColor: COLORS_ALPHA[0],
              borderColor: COLORS[0],
              borderWidth: 1,
              yAxisID: 'y'
            },
            {
              type: 'line',
              label: lineData + ' (è¶‹åŠ¿)',
              data: tab.data.matrix.map(row => row[1] || row[0] || 0),
              borderColor: COLORS[1],
              backgroundColor: COLORS_ALPHA[1],
              borderWidth: 2.5,
              tension: 0.4,
              fill: false,
              pointRadius: 4,
              yAxisID: 'y1'
            }
          ]
        },
        options: {
          layout: { padding: { top: 18, right: 14, bottom: 44, left: 8 } },
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              align: 'end'
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                label: function(context) {
                  const v = context.parsed && typeof context.parsed.y === "number" ? context.parsed.y : context.raw;
                  return context.dataset.label + ': ' + (isPercentTab(tab) ? formatPercentValue(v, tab, 1) : formatNumberCompact(v, { decimals: 2, maxDigits: 8 }));
                }
              }
            }
          },
          scales: {
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              beginAtZero: true,
              grid: {
                color: '#f3f4f6'
              },
              ticks: { color: '#6b7280', callback: (v)=>formatTick(v, tab.kind, tab), padding: 6 }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              beginAtZero: true,
              grid: {
                drawOnChartArea: false
              },
              ticks: { color: '#6b7280', callback: (v)=>formatTick(v, tab.kind, tab), padding: 6 }
            },
            x: {
              grid: {
                display: false
              },
              ticks: { color: '#6b7280', callback: (v)=>formatTick(v, tab.kind, tab), padding: 6 }
            }
          }
        }
      });
      break;

    case "stacked100":
    case "stacked100_area":
      // ç™¾åˆ†æ¯”å †å å›¾
      const isArea = tab.kind === "stacked100_area";
      const stacked100Datasets = tab.data.series.map((name, idx) => ({
        label: name,
        data: tab.data.matrix.map((row, rowIdx) => {
          const rowTotal = row.reduce((a, b) => a + b, 0);
          return rowTotal > 0 ? (row[idx] / rowTotal) * 100 : 0;
        }),
        borderColor: COLORS[idx % COLORS.length],
        backgroundColor: COLORS_ALPHA[idx % COLORS.length],
        borderWidth: isArea ? 2 : 1,
        tension: isArea ? 0.4 : 0,
        fill: true,
        pointRadius: isArea ? 0 : 3
      }));

      chart = new Chart(ctx, {
        type: isArea ? "line" : "bar",
        data: { labels: tab.data.dates, datasets: stacked100Datasets },
        options: {
          layout: { padding: { top: 18, right: 14, bottom: 44, left: 8 } },
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              align: 'end'
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                label: function(context) {
                  return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                }
              }
            }
          },
          scales: {
            y: {
              stacked: true,
              beginAtZero: true,
              max: 100,
              grid: {
                color: '#f3f4f6'
              },
              ticks: {
                callback: function(value) {
                  return value + '%';
                },
                color: '#6b7280'
              }
            },
            x: {
              stacked: true,
              grid: {
                display: false
              },
              ticks: { color: '#6b7280', callback: (v)=>formatTick(v, tab.kind, tab), padding: 6 }
            }
          }
        }
      });
      break;

    default:
      console.warn("Unsupported chart type:", tab.kind);
      canvas.parentElement.innerHTML = `
        <div class="empty-module">
          <div class="empty-module-icon">ğŸ“Š</div>
          <div>æš‚ä¸æ”¯æŒ ${tab.kind} ç±»å‹å›¾è¡¨</div>
        </div>
      `;
  }

  if (chart) {
    chartInstances[chartId] = chart;
  }
}

// æ¸²æŸ“çŸ©å½¢æ ‘å›¾
function renderTreemap(chartId, data) {
  const container = document.getElementById("treemap-" + chartId);
  if (!container || !data || !data.labels) return;

  // æ„å»ºå±‚æ¬¡æ•°æ®
  const hierarchyData = {
    name: "root",
    children: data.labels.map((label, i) => ({
      name: label,
      value: data.values[i] || 0
    }))
  };

  const width = container.clientWidth;
  const height = 320;

  const root = d3.hierarchy(hierarchyData)
    .sum(d => d.value)
    .sort((a, b) => b.value - a.value);

  d3.treemap()
    .size([width, height])
    .padding(2)
    (root);

  const svg = d3.select(container)
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  const cell = svg.selectAll("g")
    .data(root.leaves())
    .join("g")
    .attr("transform", d => `translate(${d.x0},${d.y0})`);

  cell.append("rect")
    .attr("width", d => d.x1 - d.x0)
    .attr("height", d => d.y1 - d.y0)
    .attr("fill", (d, i) => COLORS[i % COLORS.length])
    .attr("opacity", 0.8)
    .attr("stroke", "#fff")
    .attr("stroke-width", 2);

  cell.append("text")
    .attr("x", 4)
    .attr("y", 20)
    .text(d => d.data.name)
    .attr("font-size", "12px")
    .attr("fill", "#fff")
    .attr("font-weight", "600");

  cell.append("text")
    .attr("x", 4)
    .attr("y", 36)
    .text(d => d.data.value.toLocaleString())
    .attr("font-size", "11px")
    .attr("fill", "#fff")
    .attr("opacity", 0.9);
}

// æ¸²æŸ“æ‰€æœ‰å›¾è¡¨
function renderAllCharts() {
  const container = document.getElementById("modulesArea");
  container.innerHTML = "";

  Object.entries(CHARTS_BY_DOMAIN).forEach(([domain, charts]) => {
    const module = createModule(domain, charts);
    container.appendChild(module);

    const chartsContainer = module.querySelector(".charts");

    if (!charts || charts.length === 0) {
      chartsContainer.innerHTML = `
        <div class="empty-module">
          <div style="font-size:36px;opacity:0.4">ğŸ“Š</div>
          <div>æš‚æ— æŒ‡æ ‡æ•°æ®</div>
        </div>
      `;
    } else {
      charts.forEach(spec => {
        const card = createChartCard(spec);
        chartsContainer.appendChild(card);

        // æ¸²æŸ“å›¾è¡¨
        if (spec.kind === "tabbed" && spec.tabs && spec.tabs.length > 0) {
          switchTab(spec, spec.tabs[0].tab_id);
        }
      });
    }
  });
}

// AIåˆ†æå±•å¼€/æŠ˜å åŠŸèƒ½

// å…¨å±€å˜é‡å­˜å‚¨ AI åˆ†ææ•°æ®
let aiAnalysisData = {};
let aiActiveMetricId = null;

// æ–¹æ¡ˆAï¼šæ‰“å¼€ä¾§è¾¹æ æ—¶ä¸é®æŒ¡å›¾è¡¨ï¼ˆä¸»å†…å®¹è®©å‡ºå³ä¾§ç©ºé—´ï¼‰ï¼Œå¹¶è§¦å‘å›¾è¡¨ resize

// =========================
// Chart resize helper (debounced)
// =========================
let __resizeAllChartsTimer = null;
function scheduleResizeAllCharts(){
  try {
    if (__resizeAllChartsTimer) clearTimeout(__resizeAllChartsTimer);
    __resizeAllChartsTimer = setTimeout(() => {
      try { window.dispatchEvent(new Event("resize")); } catch(e) {}
      try {
        Object.keys(chartInstances || {}).forEach((k) => {
          const ch = chartInstances[k];
          if (ch && typeof ch.resize === "function") {
            try { ch.resize(); } catch(e) {}
          }
        });
      } catch(e) {}
    }, 80);
  } catch(e) {}
}

function setAIPanelCollapsed(collapsed){
  document.body.classList.toggle("ai-collapsed", !!collapsed);
  const expandBtn = document.getElementById("aiExpandBtn");
  if (expandBtn) expandBtn.style.display = collapsed ? "inline-flex" : "none";
  scheduleResizeAllCharts();
}

function setAISidebarOpen(open){
  // å…¼å®¹æ—§å‡½æ•°åï¼šopen=true => å±•å¼€ï¼›open=false => æŠ˜å 
  setAIPanelCollapsed(!open);
}

function closeAISidebar(){
  setAIPanelCollapsed(true);
}

function openAISidebar(){
  setAIPanelCollapsed(false);
}


// åŠ è½½å¹¶è§£æ AI åˆ†æå†…å®¹
function loadAIAnalysis() {
  const el = document.getElementById('ai-summary-data');
  if (!el) {
    console.warn('AI summary element not found: #ai-summary-data');
    aiAnalysisData = {};
    return;
  }
  let aiSummaryText = "";
  try {
    aiSummaryText = JSON.parse(el.textContent || '""');
  } catch (e) {
    console.error('Failed to JSON.parse ai-summary-data:', e);
    aiSummaryText = "";
  }
  console.log('AI summary raw length:', (aiSummaryText || "").length, 'head:', String(aiSummaryText || "").slice(0, 80));
  aiAnalysisData = parseAIAnalysisByMetric(aiSummaryText);
  console.log('AI åˆ†ææ•°æ®å·²åŠ è½½:', Object.keys(aiAnalysisData).length, 'ä¸ªæŒ‡æ ‡');
  console.log('å·²åŠ è½½çš„æŒ‡æ ‡åˆ—è¡¨:', Object.keys(aiAnalysisData).join(', '));
}

// æŒ‰æŒ‡æ ‡è§£æ AI åˆ†ææ–‡æœ¬
function parseAIAnalysisByMetric(text) {
  // text comes from JSON.parse(script[type=application/json]). It may contain literal "\n" sequences
  // (double-escaped) or Unicode line separators. Normalize aggressively.
  let t = String(text || "");
  if (!t || t === "æš‚æ— AIåˆ†æå†…å®¹" || t.includes("åŠ è½½AIåˆ†æå†…å®¹æ—¶å‡ºé”™")) return {};

  // normalize line breaks
  t = t.replace(/\u2028|\u2029/g, "\n");
  // if still looks like a single line but contains literal backslash-n, unescape once
  if (!t.includes("\n") && /\n/.test(t)) {
    t = t.replace(/\r\n/g, "\n").replace(/\n/g, "\n").replace(/\r/g, "\n");
  }
  // unify CRLF
  t = t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

  // strip zero-width chars that break startsWith
  const stripInvisible = (s) =>
    s.replace(/^[\uFEFF\u200B\u200C\u200D\u2060]+/, "").replace(/[\u200B\u200C\u200D\u2060]+/g, "");

  const data = {};
  const lines = t.split("\n");
  let currentModule = null;
  let currentMetricId = null;
  let bulletPoints = [];

  const flush = () => {
    if (currentMetricId && bulletPoints.length > 0) {
      data[currentMetricId] = { module: currentModule, points: [...bulletPoints] };
    }
    bulletPoints = [];
  };

  for (let i = 0; i < lines.length; i++) {
    let line = stripInvisible(lines[i] || "").trim();
    if (!line) continue;

    // module header: ## xxx
    const m1 = line.match(/^##\s+(.+)$/);
    if (m1) {
      flush();
      currentModule = m1[1].trim();
      currentMetricId = null;
      continue;
    }

    // metric id: **metric_id** (must be a standalone bold line)
    const m2 = line.match(/^\*\*([^*]+)\*\*$/);
    if (m2 && !line.includes(":")) {
      flush();
      currentMetricId = m2[1].trim();
      continue;
    }

    // bullets: â€¢ xxx  OR - xxx  OR * xxx
    const m3 = line.match(/^(?:â€¢|\-|\*)\s*(.+)$/);
    if (m3) {
      bulletPoints.push(m3[1].trim());
      continue;
    }

    // numbered list: 1. xxx
    const m4 = line.match(/^\d+\.\s*(.+)$/);
    if (m4) {
      bulletPoints.push(m4[1].trim());
      continue;
    }
  }

  flush();
  return data;
}

// æ˜¾ç¤ºæŒ‡æ ‡çš„ AI åˆ†æï¼ˆå³ä¾§å›ºå®šé¢æ¿ï¼šå®½åº¦å›ºå®šï¼Œä¸é®æŒ¡å›¾è¡¨ï¼‰
function showAIAnalysisForMetric(metricId, metricName) {
  aiActiveMetricId = (metricId || "").trim();

  const content = document.getElementById('aiSidebarContent');
  const titleEl = document.getElementById('aiPanelTitle');
  const subtitleEl = document.getElementById('aiPanelSubtitle');

  if (!content || !titleEl || !subtitleEl) return;

  const key = (metricId || "").trim();
  const analysis = aiAnalysisData[key];

  // ç¡®ä¿é¢æ¿å±•å¼€ï¼ˆæ–¹æ¡ˆAï¼šä¸»å†…å®¹è‡ªåŠ¨é€‚åº”ï¼‰
  setAIPanelCollapsed(false);

  titleEl.textContent = metricName || metricId || "AI åˆ†æ";
  subtitleEl.textContent = analysis
    ? ("å·²é€‰æŒ‡æ ‡ï¼š" + (metricName || metricId))
    : ("è¯¥æŒ‡æ ‡æš‚æ—  AI åˆ†æï¼š" + (metricName || metricId));

  if (!analysis) {
    content.innerHTML = `
      <div class="ai-empty">
        <div style="font-weight:700; margin-bottom:6px;">æš‚æ—  AI åˆ†æ</div>
        <div>è¯¥æŒ‡æ ‡åœ¨ angel_ai_summary.txt ä¸­æ²¡æœ‰å¯¹åº”æ¡ç›®ã€‚</div>
      </div>
    `;
    return;
  }

  let html = '';
  html += `<div class="ai-block">`;
  html += `<ul>`;
  (analysis.points || []).forEach((pt) => {
    const p = String(pt || '').trim();
    if (!p) return;

    // section header like "æ·±åº¦æ´å¯Ÿï¼š"
    if (/^[^:ï¼š]+[ï¼š:]$/.test(p)) {
      html += `<li class="ai-section">${escapeHtml(p.replace(/[ï¼š:]$/, ''))}</li>`;
      return;
    }

    // æ”¯æŒ "**æ ‡é¢˜**: å†…å®¹" çš„ç»“æ„
    const m = p.match(/^\*\*(.+?)\*\*\s*[ï¼š:]+\s*(.*)$/);
    if (m) {
      const t = m[1].trim();
      const c = (m[2] || '').trim();
      html += `<li><span class="ai-pill">${escapeHtml(t)}</span> ${escapeHtml(c)}</li>`;
    } else {
      html += `<li>${escapeHtml(p)}</li>`;
    }
  });
  html += `</ul>`;
  html += `</div>`;

  content.innerHTML = html;
}

// æŠ˜å  AI é¢æ¿ï¼ˆä¸é®æŒ¡å›¾è¡¨ï¼‰
function closeAISidebar() {
  aiActiveMetricId = null;
  setAIPanelCollapsed(true);
}

// HTMLè½¬ä¹‰

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;

}

// ç»‘å®šï¼šç‚¹å‡»æŒ‡æ ‡å¡ç‰‡ -> å³ä¾§å¼¹å‡ºè¯¥æŒ‡æ ‡ AI åˆ†æ
function initAISidebarBadgeClick() {
  // ç‚¹å‡»æ ‡é¢˜å³ä¾§ AI æ ‡è¯†ï¼šæ‰“å¼€/å…³é—­å³ä¾§ AI åˆ†æï¼ˆä¸é®æŒ¡ä¸»å†…å®¹ï¼‰
  document.addEventListener("click", (e) => {
    const badge = e.target.closest(".ai-badge");
    if (!badge) return;
    e.preventDefault();
    e.stopPropagation();

    const metricId = (badge.getAttribute("data-metric-id") || "").trim();
    if (!metricId) return;

    const sidebar = document.getElementById('aiSidebar');
    const isOpen = sidebar.classList.contains('active');

    // è‹¥å·²ç»æ‰“å¼€ä¸”ç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ªæŒ‡æ ‡ -> æ”¶èµ·
    if (isOpen && aiActiveMetricId && aiActiveMetricId === metricId) {
      closeAISidebar();
      return;
    }

    // å–å¡ç‰‡æ ‡é¢˜ï¼ˆå»æ‰ AI badge æ–‡æ¡ˆï¼‰
    const card = badge.closest(".chart-card");
    let metricName = metricId;
    if (card) {
      const titleEl = card.querySelector(".chart-title");
      if (titleEl) {
        const clone = titleEl.cloneNode(true);
        clone.querySelectorAll(".ai-badge").forEach(x => x.remove());
        metricName = (clone.textContent || "").trim() || metricId;
      }
    }

    showAIAnalysisForMetric(metricId, metricName);
  }, true);
}

// =========================
// URLè·¯ç”±å’ŒæŒ‡æ ‡è¯¦æƒ…é¡µåŠŸèƒ½
// =========================
let isDetailMode = false;
let currentMetricId = null;

// ä»URLè·å–å½“å‰æŒ‡æ ‡ID
function getMetricIdFromURL() {
  const hash = window.location.hash;
  if (hash.startsWith('#metric=')) {
    return decodeURIComponent(hash.substring(8));
  }
  return null;
}

// è®¾ç½®URLçš„æŒ‡æ ‡ID
function setMetricIdToURL(metricId) {
  if (metricId) {
    window.location.hash = 'metric=' + encodeURIComponent(metricId);
  } else {
    window.location.hash = '';
  }
}

// è·å–æŒ‡æ ‡çš„ç›¸å…³æŒ‡æ ‡åˆ—è¡¨
function getRelatedMetrics(metricId) {
  const allCharts = [];
  Object.values(CHARTS_BY_DOMAIN).forEach(charts => {
    allCharts.push(...charts);
  });

  const chart = allCharts.find(c => c.metric_id === metricId);
  if (!chart) return [];

  return chart.related_metrics || [];
}

// è·å–æŒ‡æ ‡åç§°
function getMetricName(metricId) {
  const allCharts = [];
  Object.values(CHARTS_BY_DOMAIN).forEach(charts => {
    allCharts.push(...charts);
  });

  const chart = allCharts.find(c => c.metric_id === metricId);
  return chart ? chart.metric_name : metricId;
}

// æ˜¾ç¤ºæŒ‡æ ‡è¯¦æƒ…é¡µ
function showMetricDetail(metricId) {
  if (!metricId) {
    returnToAllMetrics();
    return;
  }

  isDetailMode = true;
  currentMetricId = metricId;

  // æ˜¾ç¤ºé¢åŒ…å±‘
  const breadcrumb = document.getElementById('metricBreadcrumb');
  const metricNameEl = document.getElementById('currentMetricName');
  breadcrumb.style.display = 'block';
  metricNameEl.textContent = getMetricName(metricId);

  // è·å–ç›¸å…³æŒ‡æ ‡
  const relatedMetrics = getRelatedMetrics(metricId);
  const allMetricsToShow = [metricId, ...relatedMetrics];

  // éšè—å¯¼èˆªæ 
  const navTabs = document.getElementById('navTabs');
  if (navTabs) navTabs.style.display = 'none';

  // æ·»åŠ è¯¦æƒ…æ¨¡å¼class
  const modulesArea = document.getElementById('modulesArea');
  modulesArea.classList.add('detail-mode');

  // éå†æ‰€æœ‰æ¨¡å—
  const modules = document.querySelectorAll('.module-row');
  modules.forEach(module => {
    const chartsContainer = module.querySelector('.charts');
    if (!chartsContainer) return;

    const charts = module.querySelectorAll('.chart-card');
    let hasVisibleChart = false;
    let currentMetricCard = null;
    const relatedMetricCards = [];
    const otherCards = [];

    // ç¬¬ä¸€éï¼šåˆ†ç±»å¡ç‰‡
    charts.forEach(card => {
      const cardMetricId = card.dataset.metricId;

      if (allMetricsToShow.includes(cardMetricId)) {
        hasVisibleChart = true;

        if (cardMetricId === metricId) {
          // å½“å‰æŒ‡æ ‡
          card.style.display = 'block';
          card.classList.add('current-metric');
          currentMetricCard = card;
        } else {
          // ç›¸å…³æŒ‡æ ‡
          card.style.display = 'block';
          card.classList.add('related-metric');
          relatedMetricCards.push(card);
        }
      } else {
        // å…¶ä»–æŒ‡æ ‡ï¼ˆéšè—ï¼‰
        card.style.display = 'none';
        otherCards.push(card);
      }
    });

    // ç¬¬äºŒéï¼šé‡æ–°æ’åºDOMå…ƒç´ 
    // é¡ºåºï¼šå½“å‰æŒ‡æ ‡ â†’ ç›¸å…³æŒ‡æ ‡ â†’ å…¶ä»–éšè—çš„æŒ‡æ ‡
    if (hasVisibleChart && currentMetricCard) {
      // å…ˆæ·»åŠ å½“å‰æŒ‡æ ‡
      chartsContainer.appendChild(currentMetricCard);

      // å†æ·»åŠ ç›¸å…³æŒ‡æ ‡
      relatedMetricCards.forEach(card => {
        chartsContainer.appendChild(card);
      });

      // æœ€åæ·»åŠ å…¶ä»–éšè—çš„æŒ‡æ ‡ï¼ˆä¿æŒåœ¨DOMä¸­ä½†ä¸å¯è§ï¼‰
      otherCards.forEach(card => {
        chartsContainer.appendChild(card);
      });
    }

    // å¦‚æœæ¨¡å—æ²¡æœ‰å¯è§çš„å›¾è¡¨ï¼Œéšè—æ•´ä¸ªæ¨¡å—
    if (!hasVisibleChart) {
      module.classList.add('hidden-module');
    } else {
      module.classList.remove('hidden-module');

      // å¦‚æœè¿™ä¸ªæ¨¡å—åŒ…å«ç›¸å…³æŒ‡æ ‡ï¼Œæ ‡è®°æ¨¡å—å¤´
      const hasRelated = relatedMetricCards.length > 0;

      if (hasRelated) {
        const moduleHeader = module.querySelector('.module-header');
        if (moduleHeader) {
          moduleHeader.classList.add('related-section');
        }
      }
    }
  });

  // æ»šåŠ¨åˆ°é¡¶éƒ¨
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

// è¿”å›å…¨éƒ¨æŒ‡æ ‡è§†å›¾
function returnToAllMetrics() {
  isDetailMode = false;
  currentMetricId = null;

  // æ›´æ–°URL
  setMetricIdToURL(null);

  // éšè—é¢åŒ…å±‘
  const breadcrumb = document.getElementById('metricBreadcrumb');
  breadcrumb.style.display = 'none';

  // æ˜¾ç¤ºå¯¼èˆªæ 
  const navTabs = document.getElementById('navTabs');
  if (navTabs) navTabs.style.display = 'flex';

  // ç§»é™¤è¯¦æƒ…æ¨¡å¼class
  const modulesArea = document.getElementById('modulesArea');
  modulesArea.classList.remove('detail-mode');

  // é‡æ–°æ¸²æŸ“æ‰€æœ‰å›¾è¡¨ä»¥æ¢å¤åŸå§‹é¡ºåº
  renderAllCharts();

  // æ»šåŠ¨åˆ°é¡¶éƒ¨
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

// å¤„ç†URLå˜åŒ–ï¼ˆæµè§ˆå™¨å‰è¿›åé€€ï¼‰
function handleHashChange() {
  const metricId = getMetricIdFromURL();
  if (metricId) {
    showMetricDetail(metricId);
  } else if (isDetailMode) {
    returnToAllMetrics();
  }
}

// ç‚¹å‡»å›¾è¡¨å¡ç‰‡è¿›å…¥è¯¦æƒ…é¡µ
// ç‚¹å‡»View DetailsæŒ‰é’®è¿›å…¥è¯¦æƒ…é¡µ
function onViewDetailsClick(metricId, event) {
  // é˜»æ­¢äº‹ä»¶å†’æ³¡
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  // å¦‚æœå·²ç»åœ¨è¯¦æƒ…æ¨¡å¼ï¼Œä¸å“åº”ç‚¹å‡»
  if (isDetailMode) {
    return;
  }

  setMetricIdToURL(metricId);
  showMetricDetail(metricId);
}

// åˆå§‹åŒ–
function initPage() {
  initNavigation();
  renderAllCharts();

  // ç‚¹å‡»å¡ç‰‡ -> åœ¨å³ä¾§ AI é¢æ¿å±•ç¤ºå¯¹åº”æŒ‡æ ‡åˆ†æï¼ˆé¢æ¿ä¸ºå¸¸é©»åˆ—ï¼Œä¸é®æŒ¡å›¾è¡¨ï¼‰
  const modulesArea = document.getElementById("modulesArea");
  if (modulesArea){
    modulesArea.addEventListener("click", (ev) => {
      const card = ev.target.closest(".chart-card");
      if (!card) return;

      // é¿å…å¹²æ‰°ç»´åº¦åˆ‡æ¢/æŒ‰é’®/ä¸‹æ‹‰ç­‰äº¤äº’
      if (ev.target.closest("button, a, select, option, input, textarea, .dim-tabs, .dim-dropdown, .chart-actions")) return;

      const metricId = card.dataset.metricId;
      const metricName = card.dataset.metricName || metricId;

      // å¦‚æœæ²¡æœ‰å¯¹åº” AIï¼Œä¹Ÿå±•ç¤º emptyï¼ˆä½†ä»å¯å±•å¼€é¢æ¿ï¼‰
      openAISidebar();
      showAIAnalysisForMetric(metricId, metricName);
    });
  }

  loadAIAnalysis();
  // AI é¢æ¿é»˜è®¤å±•å¼€
  setAIPanelCollapsed(false);

  const collapseBtn = document.getElementById("aiCollapseBtn");
  if (collapseBtn) collapseBtn.addEventListener("click", () => setAIPanelCollapsed(true));
  const expandBtn = document.getElementById("aiExpandBtn");
  if (expandBtn) expandBtn.addEventListener("click", () => setAIPanelCollapsed(false));

    initAISidebarBadgeClick();
initAISidebarBadgeClick();

  document.getElementById("dataPeriod").textContent = new Date().toISOString().split('T')[0];
  document.getElementById("generatedAt").textContent = new Date().toLocaleString();

  // ç›‘å¬URL hashå˜åŒ–
  window.addEventListener('hashchange', handleHashChange);


  // ESC å…³é—­ AI ä¾§è¾¹æ 
  document.addEventListener('keydown', (e) => { if(e.key === 'Escape'){ closeAISidebar(); } });
// æ£€æŸ¥åˆå§‹URL
  const initialMetricId = getMetricIdFromURL();
  if (initialMetricId) {
    // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿æ‰€æœ‰å›¾è¡¨å·²æ¸²æŸ“
    setTimeout(() => showMetricDetail(initialMetricId), 100);
  }
}

document.addEventListener("DOMContentLoaded", initPage);
</script>

</body>
</html>
